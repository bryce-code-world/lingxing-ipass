# 第一期开发验收设计（DSCO-领星自动化）

本文档用于指导开发者对“一期：DSCO ↔ 领星 自动化闭环”进行验收，目标是用**最少的猜测**把系统跑通、把结果查清、把问题定位路径固化下来（保姆级指引）。

> 说明
> - 本文默认你已阅读：
>   - `doc/一期系统设计文档/1. 一期业务需求（DSCO-领星自动化）.md`
>   - `doc/一期系统设计文档/2. 一期系统设计（DSCO-领星自动化）.md`
>   - `doc/一期系统设计文档/3. 一期开发设计（DSCO-领星自动化）.md`
> - DSCO/领星的字段口径以 `golib/v2/sdk/dsco/docs/dsco-api-spec.yaml` 和 `golib/v2/sdk/lingxing/docs/*` 为准。

---

## 0. 建议验收流程（按这个顺序做，最省时间）

> 目标：先证明“程序可跑 + 可查 + 可控”，再证明“外部闭环正确”。

1. 本地单测通过：`go test ./...`
2. MySQL 建库建表：执行 `migrations/0001_init.sql`
3. 准备 `.env`：从 `.env.example` 复制并填好 DSCO/领星/MySQL/后台密码等
4. 启动服务：`go run ./cmd/ipass/main.go`
5. 打开 Admin UI：`/admin/ui/login` 登录 → `/admin/ui/` 总览确认页面可用
6. 用 Admin UI/接口确认“可追踪”：能查到水位、订单状态、人工任务、日志 trace_id
7. 先跑一轮“只写本库”的链路：`pull_dsco_orders`（验证增量水位 + 状态落库 + `dsco_order_raw` 快照）
8. 再跑外部闭环：`push_orders_to_lingxing` → `ack_to_dsco` → `ship_to_dsco` → `invoice_to_dsco`
9. 最后跑库存：`sync_stock`（验证映射注入 + 领星可用库存口径）
10. 做一次“故障演练”：验证 `IPASS_MAX_RETRY_PER_ORDER` 达到上限后转人工

重要注意：
- 当前程序中 “`/admin/run?job=...` 可触发哪些 job” 与 `.env` 中的 `IPASS_JOB_*_ENABLE` 开关口径一致：如果你要通过管理端手动触发某个 job，请确保对应的 `IPASS_JOB_*_ENABLE=true`。
- 如果你不希望调度器频繁自动执行：把 `*_INTERVAL_SEC` 调大（例如 `86400`），即可基本等同于“只手动验收触发”。

## 1. 验收目标与结论口径

一期验收以“闭环可稳定重复运行”为准，具体需要满足：

1. **订单同步（DSCO → 领星）**：可持续拉单并推单；重复运行不产生重复订单。
2. **ACK 回传（领星 → DSCO）**：满足条件后可回传；重复运行不产生重复 ACK 副作用。
3. **发货回传（领星 → DSCO）**：满足条件后回传发货信息；一期仅回传一个运单号，多包裹转人工。
4. **发票回传（当前系统 → DSCO）**：按一期最小字段集生成并回传；重复运行不重复创建。
5. **库存同步（领星 → DSCO）**：按可用库存口径同步；支持仓库与 SKU 映射注入。
6. **可运维可追踪**：能通过日志/数据库/管理接口定位到某个 `dscoOrderId` 的进度、错误与重试次数；可改水位、可手动跑任务、可查看人工任务。

---

## 2. 前置准备（必须）

### 2.1 依赖

- Go（建议 1.22+；最低建议 1.20+）
- MySQL 8+（或兼容 MySQL）
- 可访问 DSCO API 的账号与 token（建议 DSCO 测试环境/沙箱）
- 可访问 领星 OpenAPI 的 appId/accessToken（建议 领星测试环境/专用店铺）

### 2.2 验收数据（建议准备）

为避免“没有数据无法验收”，建议事先准备：

- DSCO 中至少 3 个订单（最好能覆盖）
  - 正常单：字段齐全，可推单
  - 异常单：缺少关键字段（如 `shipping.country` 或价格字段），用于验证“转人工”
  - 发货单：在领星侧可推进到“已发货”并能在 WMS 出库单查到 `tracking_no`
- 领星侧：一个明确的 `store_id`（店铺）与 `platform_code`（自定义平台），并确保平台单号唯一约束生效

> 如果你无法准备这些数据，验收只能停留在“本地单元测试全通过”，无法证明联调闭环完成。

---

## 3. 本地自检（不依赖外部系统）

### 3.1 单元测试

在项目根目录执行：

- `go test ./...`

期望：

- 全部通过（无 FAIL）
- 覆盖：mapper、pipeline、store、scheduler、adminhttp 的行为测试

### 3.2 代码格式（可选但建议）

PowerShell（推荐，避免 `gofmt` 不支持 `./...` 的误用）：

```powershell
gofmt -w (git ls-files '*.go')
```

---

## 4. 环境初始化（MySQL）

### 4.1 创建数据库与表

执行建表脚本：

- `migrations/0001_init.sql`

表清单与用途：

- `sync_order_state`：订单闭环状态（推单/ACK/发货/发票）与幂等/重试信息
- `job_watermark`：各任务水位（增量起点/断点）
- `manual_task`：人工处理队列（坏数据、多包裹、缺映射、重试上限等）
- `dsco_order_raw`：DSCO 原始订单快照（仅保留最新一份，用于审计与排查）

### 4.2 建议 SQL（验收用）

> 以下 SQL 用于验收过程“看结果”，不改数据。

- 查看某个订单闭环状态：
  - `SELECT * FROM sync_order_state WHERE dsco_order_id = 'xxx';`
- 查看失败与重试：
  - `SELECT dsco_order_id, retry_count, last_error, last_attempt_at FROM sync_order_state WHERE retry_count > 0 ORDER BY last_attempt_at DESC;`
- 查看人工任务：
  - `SELECT id, task_type, dsco_order_id, status, created_at FROM manual_task ORDER BY id DESC LIMIT 50;`
- 查看任务水位：
  - `SELECT job_name, watermark, updated_at FROM job_watermark;`

### 4.3 反复验收的“复位”方法（可选但强烈建议）

> 目的：当你需要“从头再跑一遍闭环”时，不要靠猜；用固定 SQL 复位状态。
>
> 注意：仅建议在验收环境执行，生产环境不要随意清表。

建议操作（按需选择）：

1. 清理订单状态与人工任务（保留水位）：

```sql
TRUNCATE TABLE sync_order_state;
TRUNCATE TABLE manual_task;
TRUNCATE TABLE dsco_order_raw;
```

2. 同时清理水位（完全从头再来）：

```sql
TRUNCATE TABLE job_watermark;
```

---

## 5. 配置说明（系统配置 vs 业务配置）

程序启动时会自动加载根目录 `.env`（不覆盖进程已存在的环境变量）。参考：

- `.env.example`

### 5.1 系统配置（稳定）

关键项：

- `IPASS_DB_DSN`
- `IPASS_LOG_DIR`
- `IPASS_HTTP_ENABLE` / `IPASS_HTTP_ADDR`
- `IPASS_DSCO_BASE_URL` / `IPASS_DSCO_TOKEN`
- `IPASS_LINGXING_BASE_URL` / `IPASS_LINGXING_APP_ID` / `IPASS_LINGXING_ACCESS_TOKEN`
- `IPASS_LINGXING_PLATFORM_CODE` / `IPASS_LINGXING_STORE_ID` / `IPASS_LINGXING_SID`
- `IPASS_MAX_RETRY_PER_ORDER`：同一 `dscoOrderId` 在**单个环节**的最大重试次数（默认 5）；达到上限会写入 `manual_task(task_type=max_retry_exceeded)` 并将该环节置为人工（3）

### 5.2 业务配置（口径/映射）

关键项：

- `IPASS_STOCK_WID_TO_DSCO_WAREHOUSE_CODE_JSON`：库存同步仓库映射（必填）
- `IPASS_STOCK_SKU_TO_DSCO_SKU_JSON`：库存同步 SKU 映射（可选，默认同名）
- `IPASS_SHIP_DATE_SOURCE`：发货回传 `shipDate` 取值来源
  - `delivered_at`：使用领星 WMS 的 `delivered_at`（默认）
  - `stock_delivered_at`：使用领星 WMS 的 `stock_delivered_at`
  - `none`：不回传 `shipDate`

#### 5.2.1 映射注入方式（一期统一用 env JSON）

> 一期不做“后台在线配置映射”，避免引入账号/权限/审计等复杂度；统一用 `.env` 注入，做到可复制、可回滚、可审计。

规则：
- 映射类配置使用 JSON 字符串（对象/字典）
- key/value 都按字符串处理（WID 也按字符串，例如 `"26"`）
- JSON 不合法会在启动时直接报错（配置加载校验）

PowerShell / `.env` 写法示例（注意需要转义双引号）：

```dotenv
IPASS_STOCK_WID_TO_DSCO_WAREHOUSE_CODE_JSON="{\"26\":\"WH1\",\"27\":\"WH2\"}"
IPASS_STOCK_SKU_TO_DSCO_SKU_JSON="{\"LXSKU-1\":\"DSCOSKU-1\"}"
```

#### 5.2.2 库存仓库映射（必填）

目标：把“领星仓库（WID）”映射成“DSCO warehouseCode”，用于库存回传落到正确仓库。

- 配置：`IPASS_STOCK_WID_TO_DSCO_WAREHOUSE_CODE_JSON`
- 生效范围：仅 `sync_stock` 任务
- 验收验证：
  1. 配好映射并启动服务
  2. 触发：`POST /admin/run?job=sync_stock`
  3. DSCO 侧确认库存更新落在期望 `warehouseCode`
  4. 若某个 WID 缺映射：会写入 `manual_task(task_type=missing_mapping)`（并跳过该条，不影响其他仓库推进）

#### 5.2.3 库存 SKU 映射（可选）

目标：把“领星 SKU”映射成“DSCO SKU”，用于两边 SKU 不一致时的回传纠偏。

- 配置：`IPASS_STOCK_SKU_TO_DSCO_SKU_JSON`
- 不配置时：默认同名直传（领星 SKU 原样作为 DSCO SKU）
- 验收验证：同 5.2.2，重点看 DSCO 侧最终更新的 SKU 是否符合预期

#### 5.2.4 发货回传 shipDate 口径（业务可调）

目标：发货回传时，`shipDate` 的取值来源要明确且可配置。

- 配置：`IPASS_SHIP_DATE_SOURCE`
- 可选值：
  - `delivered_at`：回传 `wms.delivered_at`
  - `stock_delivered_at`：回传 `wms.stock_delivered_at`
  - `none`：不回传 `shipDate`
- 验收验证：
  1. 触发：`POST /admin/run?job=ship_to_dsco`
  2. DSCO 侧查看该订单发货记录的 `shipDate` 是否符合配置

### 5.3 Admin 后台认证（一期最小）

- 如果配置 `IPASS_ADMIN_PASSWORD`：
  - 浏览器访问 Admin UI：先打开 `GET /admin/ui/login` 输入密码登录（写入 session cookie）
  - 脚本/命令行调用管理 API：请求头携带 `X-Admin-Password: <IPASS_ADMIN_PASSWORD>`
- 如果未配置 `IPASS_ADMIN_PASSWORD`（空字符串）：一期允许直接访问（仅建议本地开发环境使用）

---

## 6. 启动与基础检查

### 6.1 启动服务

在项目根目录执行：

- `go run ./cmd/ipass/main.go`

### 6.2 健康检查

确保 HTTP 管理端开启：`IPASS_HTTP_ENABLE=true`。

访问：

- `GET http://127.0.0.1:8080/healthz`

期望返回：

- HTTP 200
- JSON：`{"ok":true}`

### 6.3 日志检查

默认写入 `logs/`（JSON Lines）：

- `logs/info.log`
- `logs/error.log`

验收建议：

- 每次手动触发任务时，带上 `X-Trace-Id`，方便串联排查（例如 `X-Trace-Id:验收-20250101-001`）。

### 6.4 Admin UI 基础验收（必须）

1. 打开登录页：`GET /admin/ui/login`
2. 输入 `IPASS_ADMIN_PASSWORD` 登录成功后跳转到：`GET /admin/ui/`
3. 逐页点开确认都能正常返回 200：
   - 总览：`/admin/ui/`
   - 订单：`/admin/ui/orders`、`/admin/ui/order?dsco_order_id=...`
   - 人工任务：`/admin/ui/manual_tasks`
   - 水位：`/admin/ui/watermarks`
   - 任务：`/admin/ui/jobs`

期望：
- 未登录访问 `/admin/ui/` 会跳转到 `/admin/ui/login`
- 登录后刷新页面不丢 session（浏览器关闭后需重新登录）

---

## 7. 管理端运维验收（必须）

### 7.1 手动触发任务

> 注意：
> - 若你配置了 `IPASS_ADMIN_PASSWORD`，调用下面接口需带请求头：`X-Admin-Password: <IPASS_ADMIN_PASSWORD>`（或先在 `/admin/ui/login` 登录）。
> - 若要通过 `/admin/run` 触发某个 job，请确保对应的 `IPASS_JOB_*_ENABLE=true`（否则该 job 不会注册到 runner 列表）。

- `POST /admin/run?job=pull_dsco_orders`
- `POST /admin/run?job=push_orders_to_lingxing`
- `POST /admin/run?job=ack_to_dsco`
- `POST /admin/run?job=ship_to_dsco`
- `POST /admin/run?job=invoice_to_dsco`
- `POST /admin/run?job=sync_stock`

期望：

- 返回 HTTP 200：`{"ok":true}`（失败则 500，返回 error）

### 7.2 查看/修改水位

获取水位：

- `GET /admin/watermark/get?job=pull_dsco_orders`

设置水位（请求体必须是 JSON）：

- `POST /admin/watermark/set?job=pull_dsco_orders`

示例（pull_dsco_orders 的 watermark）：

```json
{"mode":"updatedSince","since":"1970-01-01T00:00:00Z"}
```

> 注意：误把 watermark 设置过大可能导致“跳过数据”；验收环境建议从小窗口开始逐步推进。

### 7.3 查看人工任务队列

- `GET /admin/manual_tasks?status=0&limit=50&offset=0`

期望：

- 能看到 bad_payload/multi_shipment/missing_mapping/max_retry_exceeded 等任务

### 7.4 按订单查询闭环状态（关键）

按单查：

- `GET /admin/order_state/get?dsco_order_id=<dscoOrderId>`

期望：

- 返回该订单的状态字段、`retry_count`、`last_error` 等，便于排障与验收截图留证

列表（按状态筛选）：

- `GET /admin/order_states?push_status=&ack_status=&ship_status=&invoice_status=&limit=50&offset=0`

---

## 8. 业务闭环验收用例（保姆级步骤）

> 说明：以下每条用例都给“操作 → 期望 → 如何确认（接口/DB/日志）”。

### 用例 A：拉取 DSCO 订单（Pull）

操作：

1. 确保 DSCO token 可用，且 DSCO 里存在测试订单
2. 触发：`POST /admin/run?job=pull_dsco_orders`

期望：

- `sync_order_state` 新增若干行（至少包含 `dsco_order_id`）
- `dsco_order_raw` 对应订单写入最新快照
- `job_watermark.pull_dsco_orders` 水位推进（`since` 变大）

确认方式：

- DB：`SELECT dsco_order_id FROM sync_order_state ORDER BY updated_at DESC LIMIT 20;`
- DB：`SELECT dsco_order_id, fetched_at FROM dsco_order_raw ORDER BY fetched_at DESC LIMIT 20;`
- 管理端：`GET /admin/watermark/get?job=pull_dsco_orders`
- 日志：搜索 `pull_orders_start/pull_orders_end`

### 用例 B：推单到领星（Push）

操作：

1. 确保已执行用例 A（或 `sync_order_state` 已有待推单订单）
2. 触发：`POST /admin/run?job=push_orders_to_lingxing`

期望：

- 成功推单：`sync_order_state.pushed_to_lx_status=1` 且 `lingxing_global_order_no` 有值
- 缺字段：写 `manual_task(task_type=bad_payload)` 且 `pushed_to_lx_status=3`
- 重复运行不重复创建（幂等）

确认方式：

- 管理端：`GET /admin/order_state/get?dsco_order_id=...`
- DB：`SELECT dsco_order_id, pushed_to_lx_status, lingxing_global_order_no, last_error FROM sync_order_state ORDER BY updated_at DESC LIMIT 20;`
- 领星侧：用“平台单号=dscoOrderId”查询是否只存在一单
- 日志：搜索 `push_orders_success/push_orders_bad_payload`

### 用例 C：ACK 回传（ACK）

操作：

1. 在领星把某个订单推进到“待发货(5)”状态（或满足一期 ACK 条件）
2. 触发：`POST /admin/run?job=ack_to_dsco`

期望：

- `acked_to_dsco_status=1`
- 重复运行不会产生重复 ACK 副作用（本地状态会挡住）

确认方式：

- 管理端：`GET /admin/order_state/get?dsco_order_id=...`
- DSCO 侧：在 DSCO 后台/查询接口确认 ACK 已生效
- 日志：搜索 `ack_success`

### 用例 D：发货回传（Ship）

操作：

1. 在领星把订单推进到“已发货(6)”
2. 确保 WMS 出库单接口能查到 `tracking_no`（且一期要求同单只匹配到一个 tracking_no）
3. 触发：`POST /admin/run?job=ship_to_dsco`

期望：

- 成功：`shipped_to_dsco_status=1` 且 `shipped_tracking_no` 记录已回传的跟踪号
- 多包裹/多跟踪号：写 `manual_task(task_type=multi_shipment)` 且 `shipped_to_dsco_status=3`
- `shipDate` 行为符合 `IPASS_SHIP_DATE_SOURCE`：
  - `delivered_at`：取 `wms.delivered_at`
  - `stock_delivered_at`：取 `wms.stock_delivered_at`
  - `none`：不回传 `shipDate`

确认方式：

- 管理端：`GET /admin/order_state/get?dsco_order_id=...`
- DSCO 侧：确认发货信息已出现（trackingNumber）
- 日志：搜索 `ship_success/ship_multi_shipment`

### 用例 E：发票回传（Invoice）

操作：

1. 确保订单存在且可开票（一期：按 `INV-<dscoOrderId>` 生成）
2. 触发：`POST /admin/run?job=invoice_to_dsco`

期望：

- 成功：`invoiced_to_dsco_status=1` 且 `dsco_invoice_id=INV-<dscoOrderId>`
- 缺价格字段：
  - unitPrice 优先 `consumerPrice`
  - 缺失时使用 `retailPrice`（以 DSCO API spec 为准）
  - 两者都缺失则转人工 `manual_task(task_type=bad_payload)` 且 `invoiced_to_dsco_status=3`
- 重复运行不重复创建（会先查 DSCO invoiceId 是否已存在）

确认方式：

- 管理端：`GET /admin/order_state/get?dsco_order_id=...`
- DSCO 侧：按 invoiceId 查询（或 DSCO 后台确认）
- 日志：搜索 `invoice_success/invoice_exists/invoice_bad_payload`

### 用例 F：库存同步（Stock）

操作：

1. 配置仓库映射：`IPASS_STOCK_WID_TO_DSCO_WAREHOUSE_CODE_JSON`（必填）
2. （可选）配置 SKU 映射：`IPASS_STOCK_SKU_TO_DSCO_SKU_JSON`
3. 触发：`POST /admin/run?job=sync_stock`

期望：

- 调用领星库存明细接口分页拉取
- 将 `product_valid_num` 按仓库映射回传 DSCO `inventory/singleItem`

确认方式：

- DSCO 侧：确认库存数值更新
- 日志：搜索 `stock_sync_start/stock_sync_end`

---

## 9. 可靠性验收（必须）

### 9.1 重试与转人工（重试上限）

目标：验证达到 `IPASS_MAX_RETRY_PER_ORDER` 后会转人工，避免无限重试。

操作（建议在测试环境）：

1. 人为制造某个环节必失败（例如临时填错 DSCO token 或让 DSCO 返回 5xx）
2. 连续多次触发对应 job（同一订单会被重复尝试）
3. 观察 `retry_count` 增长并最终转人工

期望：

- 当 `retry_count >= IPASS_MAX_RETRY_PER_ORDER`：
  - 写入 `manual_task(task_type=max_retry_exceeded)`
  - 对应环节状态变为人工（3）

确认方式：

- DB：`SELECT dsco_order_id, retry_count, last_error FROM sync_order_state WHERE dsco_order_id='xxx';`
- 管理端：`GET /admin/manual_tasks?status=0&limit=50&offset=0`

---

## 10. 常见问题排查路径（最短路线）

1. **先定位订单**：拿到 `dscoOrderId`
2. **查状态**：`GET /admin/order_state/get?dsco_order_id=...`
3. **看错误**：`last_error` + `retry_count`
4. **查日志**：用 `trace_id` 串联（调度器/管理端都支持）
5. **看人工队列**：`GET /admin/manual_tasks?status=0...`（bad_payload/multi_shipment/missing_mapping/max_retry_exceeded）
6. **必要时调水位**：`/admin/watermark/set?job=...`（谨慎使用，先备份原 watermark）

---

## 11. 验收留存建议（上线前必做）

建议在验收完成时留存以下证据（便于复盘与上线背书）：

- 每个用例（A~F）各 1 张截图：管理端 `order_state/get` 返回 + 对应外部系统（DSCO/领星）结果
- 一份 MySQL 导出（脱敏）：
  - `sync_order_state`（只保留测试订单）
  - `job_watermark`
  - `manual_task`
- 一份日志片段（按 `trace_id` 汇总）

---

## 12. 管理接口快速命令（复制即用）

> 目的：让验收过程“少点鼠标，多点可复现命令”。

### 12.1 通过请求头认证（推荐）

示例（curl）：

```bash
curl -H "X-Admin-Password: change-me" http://127.0.0.1:8080/healthz
curl -H "X-Admin-Password: change-me" "http://127.0.0.1:8080/admin/order_state/get?dsco_order_id=d1"
curl -H "X-Admin-Password: change-me" -X POST "http://127.0.0.1:8080/admin/run?job=pull_dsco_orders"
```

示例（PowerShell）：

```powershell
Invoke-RestMethod -Headers @{ "X-Admin-Password"="change-me" } -Method Get  -Uri "http://127.0.0.1:8080/healthz"
Invoke-RestMethod -Headers @{ "X-Admin-Password"="change-me" } -Method Post -Uri "http://127.0.0.1:8080/admin/run?job=pull_dsco_orders"
```

### 12.2 水位设置（验收常用）

```bash
curl -H "X-Admin-Password: change-me" -X POST \
  "http://127.0.0.1:8080/admin/watermark/set?job=pull_dsco_orders" \
  -d "{\"mode\":\"updatedSince\",\"since\":\"2025-01-01T00:00:00Z\"}"
```

建议流程：
1. 先 `GET /admin/watermark/get?job=...` 备份原值
2. 再 `POST /admin/watermark/set?job=...` 写入新值

---

## 13. 回归清单（每次改代码/发版前必过）

> 目标：避免“单测过了但联调挂了”的典型事故。

1. 单测：`go test ./...` 必须全绿
2. 启动：服务能正常启动且无 panic；`GET /healthz` 返回 `{"ok":true}`
3. 管理端认证：
   - 配置了 `IPASS_ADMIN_PASSWORD` 时，未携带认证访问 `/admin/*` 返回 401
   - Admin UI 登录可用（`/admin/ui/login` → `/admin/ui/`）
4. 管理端可运维：
   - 能读写水位：`/admin/watermark/get`、`/admin/watermark/set`
   - 能查订单状态与人工任务：`/admin/order_state/get`、`/admin/manual_tasks`
5. 可靠性兜底：
   - `IPASS_MAX_RETRY_PER_ORDER` 默认 5 生效（达到上限会写 `max_retry_exceeded` 并转人工）
6. 业务闭环（抽样 1 单即可）：
   - Pull → Push → Ack → Ship → Invoice 跑通且幂等（重复跑不产生重复外部副作用）
   - Ship 的 `shipDate` 行为与 `IPASS_SHIP_DATE_SOURCE` 一致
