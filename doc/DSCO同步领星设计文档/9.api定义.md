# 第九章 对外开放 API 定义（Open API）

本文定义“对外开放接口”的边界、鉴权方式与接口口径，用于给外部系统查询库存差异与触发库存同步。

## 0. 设计目标与约束

目标：
- 提供一个独立于 Admin 的“对外 API”入口（用于程序对接，而非人工后台）。
- 支持：
  1) 查询“当日”领星与 DSCO 库存及差异；
  2) 触发“领星库存同步更新到 DSCO”。

约束（与当前工程一致）：
- 单服务/单进程：不新增独立进程；对外 API 与 Admin UI/Admin API 仍运行在同一进程内（见 `AGENTS.md` 与架构设计）。
- **独立两套（写死）**：对外 API 与 Admin 不共用任何“业务与协议层实现细节”（handler/鉴权/session/响应封装/前端资源等均独立维护），仅共享底层基础设施（logger/DB/runtimecfg/runner/store/sdk）。
- Admin UI/Admin API 统一挂载 `/admin/*`；对外 API 挂载 `/api/*`（避免与 `/admin` 混用）。
- 数据库表结构不因本章新增接口而变更；库存差异查询优先复用 `dsco_warehouse_sync` 表（由 `sync_stock` 任务写入）。

## 1. 代码与目录约定（建议）

在仓库根目录新增 `api/` 目录，专门管理对外 API 的路由与鉴权：

```
api/
  server.go         # 路由组装：/api/v1/*
  auth.go           # Bearer Token 鉴权中间件
  inventory_api.go  # 库存差异查询 + 触发同步接口
```

说明：
- “新增一个 api 服务”在本项目语义下理解为“新增一套对外 API 模块/入口”，而不是新增独立进程。
- **禁止复用 admin 的代码**：对外 API 的鉴权/响应结构/错误码/中间件不从 `admin/*` 引用或拷贝（防止两套接口相互耦合）。
- 对外 API 只允许触发 runner（不得绕过 runner 直接调用 integration 任务）。

## 2. 配置（env.yaml）

新增配置段（示例）：

```yaml
api:
  enable: true
  token: "CHANGE_ME"
```

字段说明：
- `api.enable`：是否对外暴露 `/api/*`（建议默认 `false`，由部署环境决定是否打开）。
- `api.token`：对外 API 的固定 token（部署级机密；不进入 Admin 配置页面，不落入 runtime_config）。

## 3. 鉴权

所有 `/api/v1/*` 请求必须携带请求头：

```
Authorization: Bearer {token}
```

鉴权规则（写死）：
- 缺少/格式不合法：返回 `401 Unauthorized`
- token 不匹配：返回 `403 Forbidden`

## 4. 数据来源与实现建议

### 4.1 查询“当日库存差异”的数据来源

优先方案（推荐，复用现有能力，避免实时打爆外部 API）：
- 依赖 `sync_stock` 任务“定时拉取并记录库存对账数据”到表 `dsco_warehouse_sync`。
- 对外查询接口只做“查询当日数据”（按 `sync_time` 的 UTC 日期范围），不实时调用 DSCO/LingXing API。

建议运行方式：
- `sync_stock` 的 `jobs.sync_stock.sync=false`（只拉取与记录，不回写 DSCO），cron 建议每小时或每 2 小时跑一次，确保“当日数据”足够新。

### 4.2 触发“同步更新到 DSCO”的实现建议

不建议为了对外 API 再新增一个“重复逻辑的新任务”。

推荐方案（最小改动）：
- 复用现有任务 `sync_stock`，但为“手动触发（对外 API）”增加 override 参数：
  - 支持临时强制 `doSync=true/false`（用于 dry-run / 强制回写，不污染 runtime_config）
  - 支持两种数据来源：`daily_pulled`（基于 `dsco_warehouse_sync` 当日最新记录回写）与 `manual_items`（直接使用调用方传入的 DSCO 维度库存回写）
  - 定时任务仍由 `runtime_config.jobs.sync_stock.sync` 控制；
  - 对外 API 触发时，不修改 runtime_config（避免配置被污染/并发竞态），仅对本次运行生效。

补充：
- 对外触发时若任务正在运行，应返回 `409 Conflict`（与 Admin 行为一致，避免并发写入 DSCO）。

## 5. API 统一响应封装（建议）

对外 API 定义自己的响应 envelope（可与 Admin “长得一样”，但实现必须独立）：

```json
{ "code": 0, "message": "ok", "data": { } }
```

错误示例：
```json
{ "code": 400, "message": "invalid params" }
```

## 6. 接口定义

### 6.1 查询当日库存与差异

**GET** `/api/v1/inventory/diff`

用途：
- 查询“当日（UTC）”领星与 DSCO 库存及差异数据。

查询参数（QueryString）：
- `dsco_wid`（可选）：DSCO 仓库 id（精确匹配）
- `dsco_sku`（可选）：DSCO 的 sku（精确匹配）
- `lingxing_wid`（可选）：领星仓库 id（精确匹配）
- `lingxing_sku`（可选）：领星的 sku（精确匹配）
- `date`（可选）：UTC 日期，格式 `YYYY-MM-DD`
  - 为空：默认取当前 UTC 日期
- `diff_only`（可选）：`true/false`，为 `true` 时仅返回 `diff != 0` 的记录
- `page`（可选）：页数，默认 `1`
- `size`（可选）：分页大小，默认 `50`

数据口径：
- 数据来自表 `dsco_warehouse_sync`：
  - `lingxing_warehouse_num`：领星可用库存（ProductValidNum）
  - `dsco_warehouse_num`：DSCO 当前库存（对账读取值）
  - `diff = lingxing - dsco`
- 同一维度（dsco_warehouse_id + dsco_warehouse_sku + lingxing_warehouse_id + lingxing_warehouse_sku）在“当日”可能出现多次记录：
  - 返回时建议取“当日最新的一条”（`sync_time` 最大）

响应 `data` 示例：

```json
{
  "date": "2026-02-05",
  "items": [
    {
      "sync_time": "2026-02-05 01:06:40",
      "dsco_warehouse_id": "YQN-CA2",
      "dsco_sku": "FF002PD-DGN03",
      "dsco_num": 10,
      "lingxing_wid": "28393",
      "lingxing_sku": "FF002PD-DGN03",
      "lingxing_num": 12,
      "diff": 2
    }
  ],
  "total": 1
}
```

### 6.2 触发“领星库存同步更新到 DSCO”

**POST** `/api/v1/inventory/sync`

用途：
- 手动触发一次“领星库存 → DSCO inventory”的回写同步。
- 默认基于“当日已拉取的库存对账数据”（`dsco_warehouse_sync`）进行回写；也支持调用方手动传入多条 SKU 库存进行回写。

请求 body（JSON，可选字段）：
```json
{
  "dry_run": true
}
```

说明：
- `dry_run` 未传：（默认）按 `true` 处理；
- `dry_run=true`：（默认）仅做“选数 + 校验 + 生成 run_id 日志”，不回写 DSCO（用于外部系统先做验证）；
- `dry_run=false`：执行真实回写（对外 API 的核心诉求）。

基于“当日已拉取库存”的回写（推荐）：

```json
{
  "date": "2026-02-05",
  "dry_run": true,
  "diff_only": true,
  "dsco_wid": "YQN-CA2",
  "dsco_sku_list": ["FF002PD-DGN03", "FF002PD-DGN02"]
}
```

字段说明：
- `date`（可选）：UTC 日期，格式 `YYYY-MM-DD`；为空默认当天 UTC
- `diff_only`（可选）：只回写 `diff != 0` 的记录（默认 `true`，避免无意义更新）
- `dsco_wid`/`lingxing_wid`（可选）：限定仓库
- `dsco_sku_list`/`lingxing_sku_list`（可选）：限定 SKU 集合（多条）
- 回写目标数量：取 `dsco_warehouse_sync.lingxing_warehouse_num`（领星可用库存）
- 回写维度：按（`dsco_warehouse_id` + `dsco_warehouse_sku`）聚合，取当日最新一条（`sync_time` 最大）

手动传入多条 SKU 库存回写（兜底/补录）：

```json
{
  "dry_run": false,
  "items": [
    { "dsco_wid": "YQN-CA2", "dsco_sku": "FF002PD-DGN03", "qty": 12 },
    { "dsco_wid": "YQN-CA2", "dsco_sku": "FF002PD-DGN02", "qty": 8 }
  ]
}
```

字段说明：
- `items[]`：必填，最多 1000 条（防止单次更新过大）
- `dsco_wid`：DSCO 仓库 id（精确匹配；与 `dsco_warehouse_sync.dsco_warehouse_id` 口径一致）
- `dsco_sku`：DSCO 的 sku（精确匹配；与 `dsco_warehouse_sync.dsco_warehouse_sku` 口径一致）
- `qty`：要写入 DSCO 的库存数量（整数，>=0）

保护阈值（实现约束）：
- 当使用“当日已拉取库存”作为来源时：最多允许处理 5000 个（`dsco_warehouse_id + dsco_sku`）维度；超出则返回 400（避免误触发大规模回写）

处理口径（建议）：
- 调用 runner 执行 `sync_stock`：
  - 使用 override 让本次运行 `doSync = !dry_run`
  - 当 body 传入 `items` 时：本次运行只按 `items` 回写（不再拉取领星库存明细）
  - 当 body 未传 `items` 时：本次运行从 `dsco_warehouse_sync` 读取当日数据作为回写来源（不再重复拉取领星库存明细）
  - 不修改 `runtime_config`，避免影响定时任务口径
- 若任务运行中：返回 `409 Conflict`

响应 `data`（建议至少返回 run_id 与模式）：
```json
{
  "run_id": "1738760000000000000",
  "job": "sync_stock",
  "dry_run": false,
  "source": "daily_pulled",
  "keys": 123,
  "max_keys": 5000,
  "dsco_request_ids": ["8f8b4c6c-...."]
}
```

字段说明：
- `run_id`：本次任务执行的唯一标识（由 Runner 生成）；用于日志串联与问题排查。
- `job`：任务名；本接口固定为 `sync_stock`。
- `dry_run`：是否为演练模式；`true` 表示不回写 DSCO，仅做选数/校验/记录日志。
- `source`：本次回写的数据来源模式：
  - `daily_pulled`：基于 `dsco_warehouse_sync` 里“当日最新记录”选数后回写；
  - `manual_items`：基于请求体 `items` 直接回写。
- `keys`：本次处理的维度数量（按 `dsco_warehouse_id + dsco_sku` 聚合后的 key 数）。
- `max_keys`：保护阈值；当 `source=daily_pulled` 时用于限制最大 key 数（当前固定为 5000）。
- `dsco_request_ids`：当 `dry_run=false` 时，DSCO 异步更新接口返回的 `requestId` 列表；用于后续通过 DSCO stream/change log 跟踪最终处理结果。

> 备注：同步任务可能耗时较长；一期可先做同步阻塞响应（由调用方设置更长超时），后续如需要可再演进为“异步触发 + 查询执行进度”的模式。
