# 第六章 transport 协议层设计

本文基于：

- `doc/DSCO同步领星设计文档/1.业务需求.md`
- `doc/DSCO同步领星设计文档/2.架构设计.md`
- `doc/DSCO同步领星设计文档/3.数据库设计.md`
- `doc/DSCO同步领星设计文档/4.配置设计.md`
- `doc/DSCO同步领星设计文档/5.infra基础设施层开发设计.md`

目标：把“协议层如何触发任务执行”写清楚，并落地为可实现的目录/文件与约束口径。

## 1. transport 层定位与边界（写死）

transport 层是**协议/触发层**，只负责“把外部触发转为内部任务执行请求”，不承载任何 DSCO/领星业务规则。

transport 层包括两类触发：

1) HTTP（Gin：服务对外监听、路由挂载）
2) Scheduler（基于 cron 的定时触发器）

transport 层不做的事：

- 不写业务逻辑与字段映射（属于 `integration/*` 的任务模块）
- 不直连 DB 写业务数据（属于 `infra/*`）
- 不绕过 runner 直接调用任务（必须统一走 `integration/runner.go`）

## 2. 目录结构（精确到文件，注释即职责与依赖）

> 说明：这里仅定义 `transport/`；Admin UI/API 位于 `admin/*`，由 HTTP server 挂载到 `/admin`。

```text
transport/
├── httpserver/
│   ├── server.go              # http.Server 启动与优雅退出；挂载 /admin 与健康检查等
│   └── middleware.go          # （可选）通用中间件：request_id/访问日志/恢复等（不写业务）
│
└── scheduler/
    ├── scheduler.go           # cron 定时触发器：按 runtime_config.jobs 调度；触发时调用 runner
    ├── cron.go                # cron 解析/注册封装（要求支持 6 段含秒；UTC）
    └── types.go               # Trigger 类型：scheduled/manual（供 runner 记录与日志分类）
```

依赖关系（强约束）：

```text
transport/httpserver
  -> admin/*                    # /admin UI + API（作为 http.Handler 被挂载）
  -> integration/runner.go       # 仅用于触发（如健康检查不依赖 runner）

transport/scheduler
  -> integration/registry.go     # 任务白名单与 job 列表（防止未知 job）
  -> integration/runner.go       # 统一执行入口（快照/互斥/调用任务由 runner 负责）
  -> infra/runtimecfg            # 只读：获取“当前生效配置快照”（或由 runner 注入快照提供方）
```

## 3. HTTP Server（transport/httpserver）

### 3.1 目标

- 读取 `env.yaml` 的 `base.listen_addr` 启动监听
- 统一设置超时与优雅退出
- 挂载 Admin 后台（`/admin` 前缀）到同一服务内
- 提供最小健康检查接口（便于部署探活）

### 3.1.1 HTTP 框架选型（写死）

本项目 HTTP 框架固定选用：

- `github.com/gin-gonic/gin`

选型原因（贴合本项目需求）：

- Admin UI + Admin API 已明确使用 Gin，统一框架可减少二次封装与维护成本。
- Gin 路由分组能力强，适合“所有 Admin 接口统一 `/admin` 前缀”的约束。
- 中间件生态成熟，便于接入 request_id/访问日志/恢复等通用能力。

实现侧约束：

- `transport/httpserver` 只负责 Gin 引擎启动与挂载，不承载业务规则。
- Admin 路由由 `admin/server.go` 统一注册到 Gin engine 的 `/admin` group。

### 3.2 路由与挂载

HTTP server 至少包含：

- `/admin/*`：Admin UI + Admin API（由 `admin/server.go` 注册路由）
- `/healthz`：存活探针（仅返回 200）
- `/readyz`：就绪探针（至少检查：运行时配置已加载；必要时可做 DB ping）

> 说明：Admin 的鉴权、页面渲染、导出下载等都在 `admin/*`，transport 只负责挂载。

### 3.3 超时与限流口径（建议值）

为了兼容“导出 CSV 生成文件并立即下载（超时设置大一点）”的业务需求：

- `ReadHeaderTimeout`：5s
- `ReadTimeout`：30s
- `WriteTimeout`：建议 5m（或更大，视导出规模与网络情况）
- `IdleTimeout`：60s
- 对导出下载接口：由 Admin handler 自行控制更长的业务超时与响应策略（transport 不写业务）

> 注意：timeout 的最终值由实现评估并写进配置/代码常量；文档层仅给出建议口径。

### 3.4 优雅退出

`server.go` 需实现：

- 捕获 `SIGINT/SIGTERM`
- 先停止 scheduler（若 scheduler 与 http 同进程启动）
- 对 http server 执行 `Shutdown(ctx)`，ctx 建议 30s～60s
- 输出结构化日志：开始退出/退出完成/耗时

## 4. Scheduler（transport/scheduler）

### 4.1 目标

- 按 `runtime_config.config.jobs` 的 `cron` 与 `enable` 调度任务
- 触发任务时只调用 `integration/runner`，不承载业务
- 同一任务不允许并发：并发互斥由 runner/infra.lock 保证（transport 不重复造轮子）

### 4.2 配置来源与时区

- 配置来源：`runtime_config.config.jobs`
- cron 时区：**固定 UTC**（与 `4.配置设计.md` 一致）
- cron 格式：**必须支持 6 段（含秒）**，例如 `0 */15 * * * *`

### 4.2.1 定时包选型（写死）

本项目 Scheduler 定时库固定选用：

- `github.com/robfig/cron/v3`

选型原因（贴合本项目需求）：

- 支持“秒级 cron（6 段）”解析：通过 `cron.WithSeconds()`。
- 运行控制简单：支持 `Start/Stop`，便于“配置变更后重建调度表”的实现。
- 行为可控：可通过 `cron.WithLocation(time.UTC)` 把整个 scheduler 固定在 UTC，避免本地时区差异导致的触发偏移。
- 社区成熟、使用广泛，维护成本低。

实现侧约束（必须满足文档配置口径）：

- 创建 cron 实例时必须开启 seconds 并固定 UTC，例如：

```go
c := cron.New(
    cron.WithSeconds(),
    cron.WithLocation(time.UTC),
)
```

> 注意：如果未开启 `cron.WithSeconds()`，`0 */15 * * * *` 这类 6 段表达式会无法按预期解析（默认是 5 段，从 minute 开始）。

### 4.3 调度策略（写死）

- scheduler 启动时：加载一次当前配置快照，注册所有 `enable=true` 的 job
- 配置热更新时：当 Admin 更新 `runtime_config` 后，scheduler 需要**重建**调度表（避免老 cron 继续生效）
  - 可选实现 A：scheduler 订阅 `runtimecfg.Manager` 的“配置变更事件”，收到后重建
  - 可选实现 B：scheduler 每隔 N 秒检查一次 `runtime_config.updated_at`，变化则重建
- 重建口径：先 stop 当前 cron 实例 -> 清空 -> 重新按新配置注册 -> start

### 4.4 触发语义与参数

scheduler 对 runner 的触发只需提供：

- `jobName`：任务名称（必须来自 `integration/registry.go` 白名单）
- `trigger`：`scheduled`（便于日志与运行记录区分）
- `size`：本次执行的 size 上限（由 runner 传给任务函数作为参数的一部分）

触发失败处理（写死）：

- scheduler 触发 runner 返回错误：记录日志即可，不做重试；等待下一次 cron 或人工手动触发（符合“失败跳过，下次自动重试”的业务约束）

> 说明：外部 API 失败重试与退避属于任务内部/runner 样板，不在 scheduler 内做。

## 5. 关键约束汇总（避免协议层跑偏）

- transport 只做“触发”，所有任务执行统一走 `integration/runner.go`
- scheduler 必须支持“秒级 cron（6 段）”且固定 UTC
- 热更新口径：配置更新只影响下一次执行；scheduler 需重建调度表以反映新 cron
- 同一任务不并发：互斥锁由 `infra/lock`（PostgreSQL advisory lock）与 runner 保证
