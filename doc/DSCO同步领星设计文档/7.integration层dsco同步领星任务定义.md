# 第七章 integration 层：DSCO 同步领星任务定义

本文基于：

- `doc/DSCO同步领星设计文档/1.业务需求.md`
- `doc/DSCO同步领星设计文档/2.架构设计.md`
- `doc/DSCO同步领星设计文档/3.数据库设计.md`
- `doc/DSCO同步领星设计文档/4.配置设计.md`
- `doc/DSCO同步领星设计文档/5.infra基础设施层开发设计.md`
- `doc/DSCO同步领星设计文档/6.transport协议层设计.md`

目标：把 `integration/dsco_lingxing` 领域下的**任务清单、输入输出、依赖 SDK、字段映射、幂等与状态推进口径**写清楚，确保实现时只同步“最小必要字段”，且各任务边界可排查、可回放、可重试。

---

## 1. integration 层定位与边界（写死）

integration 层是“任务模块层”，职责是：**把 DSCO ↔ 领星的业务同步拆成若干独立任务**，由 `integration/runner.go` 提供统一样板（读取配置快照、互斥锁、调用任务函数、记录日志等）。

强约束（已确认）：

- 任务模块**禁止互调**：每个任务是一个独立职责边界，只允许被 `integration/runner.go` 调用。
- transport/admin 触发任务时，**只能调用 runner**，不得绕过 runner 直接调用任务函数。
- 任务内部只关心“做事”，不关心“触发协议”（HTTP/Scheduler）。
- 失败原因不落库，仅记录日志；失败后跳过，等待下次定时任务自动重试。

---

## 2. 目录与任务清单（一期 dsco_lingxing）

> 目录结构以 `doc/DSCO同步领星设计文档/2.架构设计.md` 为准；本章只定义任务职责与映射口径。

一期任务清单（与 `runtime_config.jobs.*` 对齐）：

- `pull_dsco_orders`：按 `created_at` 拉取 DSCO 订单入库（保存原始 payload），并初始化状态
- `push_to_lingxing`：把待同步订单写入领星（去重键：`platform_order_no = po_number`）
- `ack_to_dsco`：领星订单满足条件后回传 DSCO ACK
- `ship_to_dsco`：回传物流（运单号/承运商/发货时间/发货明细）
- `invoice_to_dsco`：回传发票（以领星实际出库为准；不回传 tracking 字段，tracking 由 `ship_to_dsco` 回传）
- `check_orders`：订单一致性检查（不落库；按时间范围或单个 PO 检查 DSCO 实际状态/发票数据与本地 status 口径是否一致；仅 Admin 手动触发）
- `sync_stock`：同步库存（领星仓库库存 → DSCO inventory）
- `pull_sku_pair`：自动拉取领星“MSKU ↔ 本地 SKU”配对关系，并更新 `runtime_config.mapping.sku`（作为手动配置的自动化补丁）

---

## 3. 任务状态机（dsco_order_sync.status）

表：`dsco_order_sync`（详见第三章）。

状态定义（写死，范围 `1~6`）：

| status | 含义 | 允许被哪个任务选中 | 成功后推进到 |
| --- | --- | --- | --- |
| 1 | 已拉单入库（待推单） | `push_to_lingxing` | 2 |
| 2 | 已写入领星（待 ACK） | `ack_to_dsco` | 3 |
| 3 | 待回传物流（shipment） | `ship_to_dsco` | 4 |
| 4 | 待回传发票（invoice） | `invoice_to_dsco` | 5 |
| 5 | 完成（已回传发票；或拉单时 dsco_status=shipped 直接完成） | 无 | 无 |
| 6 | 已取消（DSCO cancelled） | 无 | 无 |

补充约束（已确认）：

- Admin 手动拉单入库：不再支持传入/选择入库 `status`；入库 `status` 由 DSCO `dsco_status` 推导；若订单已存在则 upsert 覆盖更新 `payload` 与派生字段。
- runner 对同一任务加互斥锁；任务不并发执行（定时/手动共享互斥）。

---

## 4. SDK 依赖清单（必须明确到具体接口）

### 4.1 DSCO SDK（`golibv2/v2/sdk/dsco`）

鉴权与 base_url：

- `auth.dsco.token`（`env.yaml`）
- `integration.dsco.base_url`（`env.yaml`，可选；为空则使用 SDK 默认 BaseURLProd）

一期任务使用的 DSCO API（写死）：

| 任务 | SDK 方法 | HTTP Path | 说明 |
| --- | --- | --- | --- |
| `pull_dsco_orders` | `dsco.(*OrderService).GetPageRaw` | `GET /order/page` | 按创建时间分页拉取订单，并保留每单原始 JSON |
| `ack_to_dsco` | `dsco.(*OrderService).Acknowledge` | `POST /order/acknowledge` | 批量回传 ACK（本项目使用 `type=PO_NUMBER`） |
| `ship_to_dsco` | `dsco.(*ShipmentService).CreateSmallBatch` | `POST /order/shipment/batch/small` | 批量创建/追加发货信息（异步） |
| `invoice_to_dsco` | `dsco.(*InvoiceService).CreateSmallBatch` | `POST /invoice/batch/small` | 批量创建发票（异步） |
| `check_orders` | `dsco.(*OrderService).GetPage` / `dsco.(*InvoiceService).GetByID` | `GET /order/page` / `GET /invoice` | 查询 DSCO 订单实际状态/按 poNumber 查询发票（用于一致性检查，不写外部系统） |
| `sync_stock` | `dsco.(*InventoryService).UpdateSmallBatch` | `POST /inventory/batch/small` | 批量更新库存（异步） |

> 说明：`CreateSmallBatch`/`UpdateSmallBatch` 返回 `requestId` 可用于 DSCO change log 追踪，但本项目一期不做“运行记录落库/审计”，仅日志输出即可。

### 4.2 领星 SDK（`golibv2/v2/sdk/lingxing`）

鉴权与 base_url：

- `auth.lingxing.app_id`、`auth.lingxing.app_secret`（`env.yaml`）
- `integration.lingxing.base_url`（`env.yaml`，可选；为空则使用 SDK 默认 BaseURLProd）

一期任务使用的 领星 API（写死）：

| 任务 | SDK 方法 | HTTP Path | 说明 |
| --- | --- | --- | --- |
| `push_to_lingxing` | `lingxing.(*OrderService).CreateOrdersV2` | `POST /pb/mp/order/v2/create` | 创建多平台店铺手工单（自定义平台订单） |
| `ack_to_dsco` | `lingxing.(*OrderService).ListOrdersV2`（内部调用 list；支持 `platform_order_nos` 批量） | `POST /pb/mp/order/v2/list` | 查询订单列表/详情（按 `platform_order_no`；可能返回多条子订单） |
| `check_orders` | `lingxing.(*OrderService).ListOrdersV2`（按 `PlatformOrderNos` 批量） | `POST /pb/mp/order/v2/list` | 检查领星订单是否存在（用于一致性检查，不写外部系统） |
| `ship_to_dsco` / `invoice_to_dsco` | `lingxing.(*WarehouseService).WmsOrderList` | `POST /erp/sc/routing/wms/order/wmsOrderList` | 查询销售出库单（tracking、delivered_at、实发数量） |
| `sync_stock` | `lingxing.(*InventoryService).InventoryDetails` | `POST /erp/sc/routing/data/local_inventory/inventoryDetails` | 查询仓库库存明细（一期同步 `product_valid_num`） |

---

## 5. 映射配置（mapping）在各任务中的使用（写死）

运行时配置来源：`runtime_config.config.mapping`（详见第四章）。

约束（写死）：

- **mapping 统一用 DSCO 的标识/编码映射到领星**（key 为 DSCO，value 为 领星），避免方向混用导致误配。
- 需要反向映射（领星 → DSCO）的场景，只允许在内存中构建反向 map；若存在一对多/多对一冲突，视为配置错误并拒绝启用相关任务。

### 5.1 mapping.shop（店铺/渠道映射）

用途：在“多店铺/多渠道”场景下，把 DSCO 订单归属映射到领星 `store_id`。

- key：DSCO `order.dscoRetailerId`。
- value：领星 `store_id`。
- 同时：该 value 会用于 `WmsOrderList.sid_arr`（需能解析为 int）。
- `mapping.shop` 为必填；若某单无法映射到 store_id，则该单推单会被跳过并记录日志。

### 5.2 mapping.warehouse（仓库映射）

用途：把 DSCO `warehouseCode` 映射到领星仓库 ID（WID）。

- key：DSCO `warehouseCode`（字符串）
- value：领星 WID（字符串，例如 `"26"`）
- `sync_stock` 启用前要求 `mapping.warehouse` 非空。
  - `jobs.sync_stock.sync=false` 时：只拉取并记录领星库存明细，不回写 DSCO inventory。

反向映射要求：

- `sync_stock` 在写入 DSCO inventory 时需要 `WID -> warehouseCode`，因此实现侧必须构建反向 map：`wid_to_dsco_warehouse_code`。

### 5.3 mapping.sku（SKU 映射）

用途：解决两端 SKU 不一致的问题。

一期确认（写死）：

- 配置方向（写死）：**DSCO SKU（优先 partnerSku，否则 sku） -> 领星 SKU**。
- 推单到领星（`push_to_lingxing`）：
  - `msku`：始终使用 DSCO 行项目 SKU（优先 partnerSku，否则 sku）。
  - `sku`：若 `mapping.sku` 中存在映射，则补齐领星平台维度 `sku`；若无映射则不传（omitempty）。
- 领星 → DSCO 回传（`ship_to_dsco` / `invoice_to_dsco` / `sync_stock`）：
  - 领星侧返回的 `sku` 需要回写为 DSCO 的 `partnerSku` 口径，因此实现侧在运行时构建反向映射（领星 SKU -> DSCO SKU）。
  - 若反向映射存在一对多/多对一冲突，视为配置错误并拒绝启用相关任务（避免回传错配）。

### 5.4 mapping.shipment（物流方式映射）

用途：推单到领星时，填写 `logistics_type_id`（领星文档口径：当填写 `wid` 时，`logistics_type_id` 必填）。

- key：`<shipWarehouseCode>-<shippingServiceLevelCode>`（字符串拼接；若 shipWarehouseCode 为空，可用 requestedWarehouseCode 兜底）
- value：领星 `logistics_type_id`（字符串）

约束（写死）：

- `push_to_lingxing`：当 `wid` 非空时，必须能通过 `mapping.shipment` 得到 `logistics_type_id`；否则该订单会被跳过并记录日志。

---

## 6. 字段映射与“最小必要字段”策略

### 6.1 DSCO 拉单（DSCO → 本地入库）

DSCO 拉单 API：`GET /order/page`（`dsco.Order.GetPageRaw`）。

拉取窗口口径（已确认）：

- 基于 DSCO `created_at`（本项目使用 `order.dscoCreateDate`，RFC3339）
- 时间范围边界：`[start, end)`（UTC）

游标口径（已确认）：

- “最新时间”来自 `dsco_order_sync.dsco_create_time`（UTC 秒级时间戳）；
- 若表为空：从 `2025-01-01 00:00:00Z` 开始；
- 不单独存储游标表。

入库时必须保存的最小字段（建议 store 层结构化列 + payload 原文）：

- `po_number`（唯一键）：来源接口返回 `order.PoNumber`
- `dsco_create_time`：由 `order.DscoCreateDate` 解析为 UTC 秒级时间戳
- `payload`：原始 JSON，允许覆盖更新
- `status`：默认 1，或 Admin 手动指定
- `mskus`：按 `order.LineItems` 逐行写入 `sku(quantity)`（保留重复行）
- `warehouse_id`: `order.ShipWarehouseCode`
- `shipment`: `order.ShippingServiceLevelCode`

### 6.2 推单（DSCO → 领星：创建订单）

领星创建订单 API：`POST /pb/mp/order/v2/create`（`lingxing.Order.CreateOrdersV2`）。

去重键（写死）：

- 领星侧唯一键：`platform_order_no`
- 本项目映射：`platform_order_no = dsco.po_number`

创建订单的最小必要字段（按领星 SDK 结构）：

- 请求：`CreateOrdersV2Request`
  - `platform_code`：来自 `env.yaml integration.lingxing.platform_code`
  - `store_id`：来自 `mapping.shop`，取 `key` 为 dsco 订单中的  `order.dscoRetailerId` 映射值，如果没有映射配置，则直接跳过，记录日志，不同步
- 每个订单：`CreateOrderV2`
  - `platform_order_no`：DSCO `poNumber`
  - `receiver_country_code`：DSCO `shipping.country`（建议为两位国家码，如 `US`）
  - `receiver_name`：优先 DSCO `shipping.name`；否则拼 `firstName + lastName`
  - `state_or_region`：DSCO `shipping.state`（美国等场景下建议必填；缺失可能导致下游物流下单失败）
  - `city`：DSCO `shipping.city`
  - `address_line1`：优先 DSCO `shipping.address1`；否则取 `shipping.address[0]`
  - `postal_code`：DSCO `shipping.postal`（可选，但建议尽量补齐）
  - `receiver_mobile`：DSCO `shipping.phone`（可选）
  - `buyer_email`：DSCO `shipping.email`（可选）
  - `buyer_note`：DSCO `message/buyerMessage`（可选）
  - `wid`：由 DSCO 仓库编码通过 `mapping.warehouse` 映射得到（为空允许不传）
  - `logistics_type_id`：由 `<ShipWarehouseCode(空则用 RequestedWarehouseCode)>-<ShippingServiceLevelCode>` 通过 `mapping.shipment` 映射得到（当 `wid` 非空时必填；映射失败则跳过）
  - `items[]`：逐行映射
    - `msku`：DSCO 行项目 SKU（优先 `partnerSku`，否则 `sku`），直接赋值到领星 `msku`
    - `sku`：若 `mapping.sku` 中存在映射，则补齐领星平台维度 `sku`；若无映射则不传（omitempty）
    - `quantity`：DSCO `lineItems[].quantity`
    - `unit_price`：用于满足领星必填字段，按以下优先级取值：
      1) DSCO `lineItems[].consumerPriceWithTax`
      2) DSCO `lineItems[].consumerPrice`
      3) DSCO `lineItems[].retailPrice`
      4) DSCO `lineItems[].expectedCost`
      5) 若以上均为空：视为数据缺失，记录日志并跳过该订单（状态不推进，等待后续人工排查）

> 最小字段原则：除以上字段外，其余（如站点、物流渠道、地址2、备注等）一期不主动同步，除非出现真实业务需求再补齐。

### 6.3 ACK（领星 → DSCO：订单已审核/已发货回传）

DSCO ACK API：`POST /order/acknowledge`（`dsco.Order.Acknowledge`）。

ACK 条件（已确认）：

- 领星订单状态 `status` 为 `5/6`（`待发货/已发货`）即可 ACK
  - 对应枚举：`lingxing.MultiPlatformOrderStatusPendingShipment (5)` / `Shipped (6)`
- 配置开关（可选）：若 `runtime_config.jobs.ack_to_dsco.multi_ban=true` 且该订单为“多行/多数量”订单（`mskus` 行数 > 1 或任一行 `quantity > 1`），则本任务跳过该订单的 ACK 回传（不调用 DSCO ACK 接口；本地状态保持不变，除非 DSCO 实际状态已进入后续阶段而被同步推进）。

领星查询来源：

- `lingxing.Order.ListOrdersV2`（可批量按 `platform_order_no` 查询）
  - 说明：同一 `poNumber` 在领星侧可能出现“拆单子订单”（查询结果可能返回多条）；ACK 必须在 **该 poNumber 下所有子订单** 均满足 `status=5/6` 时才允许回传，避免过早 ACK。
  - 兼容：当批量查询失败时可降级为逐单 `GetOrderDetailV2`。

DSCO ACK 最小必要字段：

- `OrderAcknowledgeRequest`
  - `type = PO_NUMBER`
  - `id = poNumber`

### 6.4 物流回传（领星 → DSCO：shipment）

DSCO shipment API：`POST /order/shipment/batch/small`（`dsco.Shipment.CreateSmallBatch`）。

幂等（写死）：

- 不以本地 `dsco_order_sync.shipped_tracking_no` 判断是否跳过；每次任务先查询 DSCO 实际 `dscoStatus`：`shipped/completed` 跳过并推进状态，`shipment_pending` 才回传物流信息。
- 配置开关（可选）：若 `runtime_config.jobs.ship_to_dsco.multi_ban=true` 且该订单为“多行/多数量”订单（`mskus` 行数 > 1 或任一行 `quantity > 1`），则本任务跳过该订单的物流回传（不调用 DSCO shipment 接口；本地状态保持不变，除非 DSCO 已 shipped/completed 而被同步推进）。

领星数据来源与优先级（写死）：

1) 使用 `lingxing.Warehouse.WmsOrderList` 获取运单号、发货时间与实发数量：
   - 入参：
     - `platform_order_no_arr = [poNumber]`
     - `sid_arr = [SID]`：
       - SID 获取方式（写死）：从 DSCO 原始订单取 `dscoRetailerId`，通过 `runtime_config.mapping.shop` 映射得到领星 SID（字符串，需可解析为 int）
   - 取值：
     - `tracking_no`（运单号）
     - `delivered_at`（字符串时间，用于回传 DSCO 的 shipDate）
     - 若 `delivered_at` 为空：使用 `stock_delivered_at` 兜底
     - `product_info[]`（`sku` + `count`，用于实发数量）
   - 前置条件（写死）：只处理 `WmsOrder.status = 3`（已发货）的出库单；其他状态不回传（避免 shipDate 为空值/过早回传）。
2) 若 WmsOrderList 无数据（或筛选后无 `status=3` 的记录），认为“暂未满足回传条件”，等待下次任务重试（不再用订单详情兜底拼 shipDate）。

多运单号/多出库单（写死）：

- `WmsOrderList` 可能返回多条出库单，且同一 `poNumber` 可能对应多个 `tracking_no`。
- 回传 DSCO 时按 `tracking_no` 聚合生成多条 `ShipmentForUpdate`（同一 poNumber 的 shipments[] 允许多条）。
- 本地写回 `shipped_tracking_no` 时，使用**英文逗号**拼接去重后的 tracking 列表（便于展示与 Admin 筛选；不作为是否回传 shipment 的判断依据）。

发货时间口径（已确认，写死）：

- DSCO `shipDate` 统一取自 `WmsOrder.status=3` 的出库单：优先 `WmsOrder.DeliveredAt`；为空则 `WmsOrder.StockDeliveredAt` 兜底；并转换为 DSCO 要求的 ISO 8601/RFC3339（如 `YYYY-MM-DDTHH:MM:SSZ`）。

字段映射（最小必要字段）：

- 领星 → DSCO：
  - `tracking_no` → `trackingNumber`（必填）
  - `shipMethod`：使用 DSCO 原始订单中的 `shipMethod/requestedShipMethod`；若为空则使用 `shippingServiceLevelCode` 兜底
  - `shipDate`：优先 `WmsOrder.DeliveredAt`；为空则 `WmsOrder.StockDeliveredAt`；转换为 RFC3339
- 发货行项目：
  - 来源：优先用 WmsOrderList `product_info[]`（SKU+count）
  - SKU 映射：领星 SKU 通过 `mapping.sku` 的**反向映射**得到 DSCO `partnerSku`（缺省同名直传）
  - DSCO 行项目标识：优先写入 `partnerSku`；如能从 DSCO 原始订单中匹配到 `dscoItemId` 与 `lineNumber`，可额外带上以增强唯一性（提升 DSCO 侧匹配成功率）

### 6.5 发票回传（领星 → DSCO：invoice）

DSCO invoice API：`POST /invoice/batch/small`（`dsco.Invoice.CreateSmallBatch`）。

发票生成原则（已确认）：

- 发票所需“关联字段”主要来自 DSCO 原始订单（`payload`）
- **实发数量**与**订单金额**以领星侧实际出库/订单查询结果为准

数据来源（写死）：

- 领星出库与实发数量：`lingxing.Warehouse.WmsOrderList` 的 `product_info[]`
- 领星运单号/发货时间：同 6.4（与 shipment 共用）

幂等（写死）：

- 定时批处理：若本地 `dsco_order_sync.dsco_invoice_id` 已有值，视为已回传过发票，直接跳过（不重复回传）。
- Admin 手动指定 `po_number` 重试：不因本地已有 `dsco_invoice_id` 跳过，仍继续执行并校验 DSCO 侧“发票是否真实存在/是否成功”；若校验失败则不推进本地状态。
- 配置开关（可选）：若 `runtime_config.jobs.invoice_to_dsco.multi_ban=true` 且该订单为“多行/多数量”订单（`mskus` 行数 > 1 或任一行 `quantity > 1`），则本任务跳过该订单的发票回传（不调用 DSCO invoice 接口；本地状态保持不变）。

回传口径（一期最新确认，写死）：

- 以 `poNumber` 为维度：同一 `poNumber` 即使在领星侧存在拆单子订单/多行，也只回传 **1 张汇总发票** 给 DSCO。
- 前置条件：`poNumber` 下所有 SKU 均已发货
  - 判断方式：聚合 `WmsOrderList.product_info` 的已发货数量（按 `mapping.sku` 反向映射到 DSCO partnerSku 口径），要求对 DSCO 原始订单每个 `partnerSku` 满足 `shipped_qty >= expected_qty`。
- `invoiceId`：固定为 `poNumber`。
- `trackingNumber`：取 `WmsOrderList.tracking_no` 的去重集合；若多运单号则用英文逗号拼接（便于排查）。
- `invoiceDate`：取 `WmsOrderList` 中“最晚一次发货时间”（优先 `delivered_at`，为空则 `stock_delivered_at`），转换为 RFC3339。

DSCO Invoice 最小必要字段（按 SDK 结构）：

- `invoiceId`：`poNumber`
- 订单关联字段：`poNumber`（或 `dscoOrderId` 二选一；本项目统一用 `poNumber`）
- `trackingNumber`：见上
- `invoiceDate`：见上
- `currencyCode`：优先从 DSCO 原始订单中取
- `lineItems[]`：
  - 数量：使用 DSCO 原始订单数量（因“必须全量发货”后才回传）
  - 标识字段：优先写 `partnerSku`（由 `mapping.sku` 的**反向映射**得到），并尽量补齐 `dscoItemId` / `lineNumber`
  - `unitPrice`：同 6.2 的单价规则（优先 DSCO 原始订单提供的价格字段）
- `totalAmount`：按 `sum(lineItem.quantity * unitPrice)` 计算，并 round 到 2 位小数

### 6.6 库存同步（领星 → DSCO：inventory）

目标：把领星各仓库的“可用量”同步到 DSCO inventory。

领星库存来源：

- `lingxing.Inventory.InventoryDetails`
  - 使用字段：`sku`、`product_valid_num`（可用量）、`wid`

DSCO 更新方式：

- `dsco.Inventory.UpdateSmallBatch`（异步）
  - 每个 item：`ItemInventory{ PartnerSKU, Warehouses: [{code, quantity}] }`

字段映射（最小必要字段）：

- 仓库映射：`wid`（领星） → `warehouseCode`（DSCO），使用 `mapping.warehouse` 的**反向映射**
- SKU 映射：领星 `sku` → DSCO `partnerSku`，使用 `mapping.sku` 的**反向映射**（缺省同名直传）
- 数量：`product_valid_num` → DSCO `warehouses[].quantity`

落库（用于 Admin 查询/导出）：

- `dsco_warehouse_sync`：记录每次同步的时间窗口、仓库、SKU、数量等（字段以第三章为准）

### 6.7 订单一致性检查（DSCO ↔ 本地/领星，不落库）

目标：在不改表/不落库的前提下，按时间窗口（`dsco_create_time`）或单个 `po_number`，检查“外部系统真实数据”与“本地状态推进”是否一致，便于发现漏拉单/漏回传/状态被误改等问题。

触发方式（写死）：
- 仅 Admin 手动触发（非定时任务）；返回结果通过 runner 的 `TaskContext.Report` 同步回传给调用方。

检查输入：
- 时间范围检查：`[start,end)`（Unix 秒，UTC），按 DSCO `order.dscoCreateDate` 拉取 DSCO 订单；
- 单订单检查：指定 `po_number`，优先按单号拉取 DSCO 订单与本地记录。

一致性判定（以“本地 status 作为期望口径”）：
- `status=1`：不检查（跳过）
- `status=2`：检查领星是否存在订单（`lingxing.Order.ListOrdersV2`，按 `PlatformOrderNos` 批量查询）
- `status=3`：检查 DSCO 状态是否为 `shipment_pending/shipped/completed`
- `status=4`：检查 DSCO 状态是否为 `shipped/completed`
- `status=5`：检查 DSCO 是否存在发票（`dsco.Invoice.GetByID`，`key=poNumber&value={po}`，只要返回有 invoices 即视为存在）
- DSCO 范围内存在但本地不存在：标记异常 `missing_local_record`（提示可能漏拉单/漏入库）

---

## 7. 任务的批量、并发与失败处理（统一口径）

批量大小：

- 所有任务统一使用 `runtime_config.config.jobs.<job>.size` 作为单次处理上限。
- DSCO/领星接口批量能力差异由实现自行拆分，但“对外配置口径”固定为 `size`。

并发：

- 不允许同一任务并发（由 runner + PostgreSQL advisory lock 保证）。

失败处理：

- 单批中部分失败：记录日志并跳过，等待下次 cron 自动重试（符合一期“简单优先”的要求）。
- 不落库失败原因；需要排查时查看日志。

日志与可观测性（一期口径）：

- runner 会为每次任务执行生成 `run_id`，任务内所有明细日志均携带 `run_id`，便于按单次执行串联排查。
- 每个任务必须打印：`task begin` / `task end`；并对每个订单打印 `order done`（包含 `po_number`、`result`、`reason`、必要的原始数据快照）。
- 手动触发“单订单执行”时，runner/任务会携带 `only_po_number`，并且任务取数必须按该 `po_number` 精确过滤，避免影响其他订单。
