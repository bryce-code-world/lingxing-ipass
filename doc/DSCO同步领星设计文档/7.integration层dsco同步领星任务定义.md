# 第七章 integration 层：DSCO 同步领星任务定义

本文基于：

- `doc/DSCO同步领星设计文档/1.业务需求.md`
- `doc/DSCO同步领星设计文档/2.架构设计.md`
- `doc/DSCO同步领星设计文档/3.数据库设计.md`
- `doc/DSCO同步领星设计文档/4.配置设计.md`
- `doc/DSCO同步领星设计文档/5.infra基础设施层开发设计.md`
- `doc/DSCO同步领星设计文档/6.transport协议层设计.md`

目标：把 `integration/dsco_lingxing` 领域下的**任务清单、输入输出、依赖 SDK、字段映射、幂等与状态推进口径**写清楚，确保实现时只同步“最小必要字段”，且各任务边界可排查、可回放、可重试。

---

## 1. integration 层定位与边界（写死）

integration 层是“任务模块层”，职责是：**把 DSCO ↔ 领星的业务同步拆成若干独立任务**，由 `integration/runner.go` 提供统一样板（读取配置快照、互斥锁、调用任务函数、记录日志等）。

强约束（已确认）：

- 任务模块**禁止互调**：每个任务是一个独立职责边界，只允许被 `integration/runner.go` 调用。
- transport/admin 触发任务时，**只能调用 runner**，不得绕过 runner 直接调用任务函数。
- 任务内部只关心“做事”，不关心“触发协议”（HTTP/Scheduler）。
- 失败原因不落库，仅记录日志；失败后跳过，等待下次定时任务自动重试。

---

## 2. 目录与任务清单（一期 dsco_lingxing）

> 目录结构以 `doc/DSCO同步领星设计文档/2.架构设计.md` 为准；本章只定义任务职责与映射口径。

一期任务清单（与 `runtime_config.jobs.*` 对齐）：

- `pull_dsco_orders`：按 `created_at` 拉取 DSCO 订单入库（保存原始 payload），并初始化状态
- `push_to_lingxing`：把待同步订单写入领星（去重键：`platform_order_no = po_number`）
- `ack_to_dsco`：领星订单满足条件后回传 DSCO ACK
- `ship_to_dsco`：回传物流（运单号/承运商/发货时间/发货明细）
- `invoice_to_dsco`：回传发票（以领星实际出库为准）
- `sync_stock`：同步库存（领星仓库库存 → DSCO inventory）

---

## 3. 任务状态机（dsco_order_sync.status）

表：`dsco_order_sync`（详见第三章）。

状态定义（写死，范围 `1~6`）：

| status | 含义 | 允许被哪个任务选中 | 成功后推进到 |
| --- | --- | --- | --- |
| 1 | 已拉单入库（待推单） | `push_to_lingxing` | 2 |
| 2 | 已写入领星（待 ACK） | `ack_to_dsco` | 3 |
| 3 | 待回传物流（shipment） | `ship_to_dsco` | 4 |
| 4 | 待回传发票（invoice） | `invoice_to_dsco` | 5 |
| 5 | 完成（已回传发票；或拉单时 dsco_status=shipped 直接完成） | 无 | 无 |
| 6 | 已取消（DSCO cancelled） | 无 | 无 |

补充约束（已确认）：

- Admin 手动拉单入库：不再支持传入/选择入库 `status`；入库 `status` 由 DSCO `dsco_status` 推导；若订单已存在则 upsert 覆盖更新 `payload` 与派生字段。
- runner 对同一任务加互斥锁；任务不并发执行（定时/手动共享互斥）。

---

## 4. SDK 依赖清单（必须明确到具体接口）

### 4.1 DSCO SDK（`golibv2/v2/sdk/dsco`）

鉴权与 base_url：

- `auth.dsco.token`（`env.yaml`）
- `integration.dsco.base_url`（`env.yaml`，可选；为空则使用 SDK 默认 BaseURLProd）

一期任务使用的 DSCO API（写死）：

| 任务 | SDK 方法 | HTTP Path | 说明 |
| --- | --- | --- | --- |
| `pull_dsco_orders` | `dsco.(*OrderService).GetPageRaw` | `GET /order/page` | 按创建时间分页拉取订单，并保留每单原始 JSON |
| `ack_to_dsco` | `dsco.(*OrderService).Acknowledge` | `POST /order/acknowledge` | 批量回传 ACK（本项目使用 `type=PO_NUMBER`） |
| `ship_to_dsco` | `dsco.(*ShipmentService).CreateSmallBatch` | `POST /order/shipment/batch/small` | 批量创建/追加发货信息（异步） |
| `invoice_to_dsco` | `dsco.(*InvoiceService).CreateSmallBatch` | `POST /invoice/batch/small` | 批量创建发票（异步） |
| `sync_stock` | `dsco.(*InventoryService).UpdateSmallBatch` | `POST /inventory/batch/small` | 批量更新库存（异步） |

> 说明：`CreateSmallBatch`/`UpdateSmallBatch` 返回 `requestId` 可用于 DSCO change log 追踪，但本项目一期不做“运行记录落库/审计”，仅日志输出即可。

### 4.2 领星 SDK（`golibv2/v2/sdk/lingxing`）

鉴权与 base_url：

- `auth.lingxing.app_id`、`auth.lingxing.app_secret`（`env.yaml`）
- `integration.lingxing.base_url`（`env.yaml`，可选；为空则使用 SDK 默认 BaseURLProd）

一期任务使用的 领星 API（写死）：

| 任务 | SDK 方法 | HTTP Path | 说明 |
| --- | --- | --- | --- |
| `push_to_lingxing` | `lingxing.(*OrderService).CreateOrdersV2` | `POST /pb/mp/order/v2/create` | 创建多平台店铺手工单（自定义平台订单） |
| `ack_to_dsco` / `ship_to_dsco` / `invoice_to_dsco` | `lingxing.(*OrderService).GetOrderDetailV2`（内部调用 list） | `POST /pb/mp/order/v2/list` | 查询单个订单详情（按 `platform_order_no` 查） |
| `ship_to_dsco` / `invoice_to_dsco` | `lingxing.(*WarehouseService).WmsOrderList` | `POST /erp/sc/routing/wms/order/wmsOrderList` | 查询销售出库单（tracking、delivered_at、实发数量） |
| `sync_stock` | `lingxing.(*InventoryService).InventoryDetails` | `POST /erp/sc/routing/data/local_inventory/inventoryDetails` | 查询仓库库存明细（一期同步 `product_valid_num`） |

---

## 5. 映射配置（mapping）在各任务中的使用（写死）

运行时配置来源：`runtime_config.config.mapping`（详见第四章）。

约束（写死）：

- **mapping 统一用 DSCO 的标识/编码映射到领星**（key 为 DSCO，value 为 领星），避免方向混用导致误配。
- 需要反向映射（领星 → DSCO）的场景，只允许在内存中构建反向 map；若存在一对多/多对一冲突，视为配置错误并拒绝启用相关任务。

### 5.1 mapping.shop（店铺/渠道映射）

用途：在“多店铺/多渠道”场景下，把 DSCO 订单归属映射到领星 `store_id`。

- key：DSCO `order.dscoRetailerId`。
- value：领星 `store_id`。
- 同时：该 value 会用于 `WmsOrderList.sid_arr`（需能解析为 int）。
- `mapping.shop` 为必填；若某单无法映射到 store_id，则该单推单会被跳过并记录日志。

### 5.2 mapping.warehouse（仓库映射）

用途：把 DSCO `warehouseCode` 映射到领星仓库 ID（WID）。

- key：DSCO `warehouseCode`（字符串）
- value：领星 WID（字符串，例如 `"26"`）
- `sync_stock` 启用前要求 `mapping.warehouse` 非空。

反向映射要求：

- `sync_stock` 在写入 DSCO inventory 时需要 `WID -> warehouseCode`，因此实现侧必须构建反向 map：`wid_to_dsco_warehouse_code`。

### 5.3 mapping.sku（SKU 映射）

用途：解决两端 SKU 不一致的问题。

一期确认（写死）：

- 同步订单到领星时：SKU 不做映射，直接把 DSCO 订单行的 SKU（优先 partnerSku，否则 sku）赋值到领星建单参数 `msku`，由领星侧自动匹配。
- `mapping.sku` 仅用于“库存回写 DSCO”场景：配置方向为 **DSCO partnerSku -> 领星 SKU**；实现侧在运行时构建反向映射（领星 SKU -> DSCO partnerSku）用于回写入参；缺省同名直传。

### 5.4 mapping.shipment（物流方式映射）

用途：推单到领星时，填写 `logistics_type_id`（领星文档口径：当填写 `wid` 时，`logistics_type_id` 必填）。

- key：`<shipWarehouseCode>-<shippingServiceLevelCode>`（字符串拼接；若 shipWarehouseCode 为空，可用 requestedWarehouseCode 兜底）
- value：领星 `logistics_type_id`（字符串）

约束（写死）：

- `push_to_lingxing`：当 `wid` 非空时，必须能通过 `mapping.shipment` 得到 `logistics_type_id`；否则该订单会被跳过并记录日志。

---

## 6. 字段映射与“最小必要字段”策略

### 6.1 DSCO 拉单（DSCO → 本地入库）

DSCO 拉单 API：`GET /order/page`（`dsco.Order.GetPageRaw`）。

拉取窗口口径（已确认）：

- 基于 DSCO `created_at`（本项目使用 `order.dscoCreateDate`，RFC3339）
- 时间范围边界：`[start, end)`（UTC）

游标口径（已确认）：

- “最新时间”来自 `dsco_order_sync.dsco_create_time`（UTC 秒级时间戳）；
- 若表为空：从 `2025-01-01 00:00:00Z` 开始；
- 不单独存储游标表。

入库时必须保存的最小字段（建议 store 层结构化列 + payload 原文）：

- `po_number`（唯一键）：来源接口返回 `order.PoNumber`
- `dsco_create_time`：由 `order.DscoCreateDate` 解析为 UTC 秒级时间戳
- `payload`：原始 JSON，允许覆盖更新
- `status`：默认 1，或 Admin 手动指定
- `mskus`：`order.LineItems.sku`
- `warehouse_id`: `order.ShipWarehouseCode`
- `shipment`: `order.ShippingServiceLevelCode`

### 6.2 推单（DSCO → 领星：创建订单）

领星创建订单 API：`POST /pb/mp/order/v2/create`（`lingxing.Order.CreateOrdersV2`）。

去重键（写死）：

- 领星侧唯一键：`platform_order_no`
- 本项目映射：`platform_order_no = dsco.po_number`

创建订单的最小必要字段（按领星 SDK 结构）：

- 请求：`CreateOrdersV2Request`
  - `platform_code`：来自 `env.yaml integration.lingxing.platform_code`
  - `store_id`：来自 `mapping.shop`，取 `key` 为 dsco 订单中的  `order.dscoRetailerId` 映射值，如果没有映射配置，则直接跳过，记录日志，不同步
- 每个订单：`CreateOrderV2`
  - `platform_order_no`：DSCO `poNumber`
  - `receiver_country_code`：DSCO `shipping.country`（建议为两位国家码，如 `US`）
  - `receiver_name`：优先 DSCO `shipping.name`；否则拼 `firstName + lastName`
  - `city`：DSCO `shipping.city`
  - `address_line1`：优先 DSCO `shipping.address1`；否则取 `shipping.address[0]`
  - `wid`：由 DSCO 仓库编码通过 `mapping.warehouse` 映射得到（为空允许不传）
  - `logistics_type_id`：由 `<ShipWarehouseCode(空则用 RequestedWarehouseCode)>-<ShippingServiceLevelCode>` 通过 `mapping.shipment` 映射得到（当 `wid` 非空时必填；映射失败则跳过）
  - `items[]`：逐行映射
    - `msku`：DSCO 行项目 SKU（一期不做映射：优先 `partnerSku`，否则 `sku`），直接赋值到领星 `msku`，由领星侧自动匹配
    - `quantity`：DSCO `lineItems[].quantity`
    - `unit_price`：用于满足领星必填字段，按以下优先级取值：
      1) DSCO `lineItems[].consumerPriceWithTax`
      2) DSCO `lineItems[].consumerPrice`
      3) DSCO `lineItems[].retailPrice`
      4) DSCO `lineItems[].expectedCost`
      5) 若以上均为空：视为数据缺失，记录日志并跳过该订单（状态不推进，等待后续人工排查）

> 最小字段原则：除以上字段外，其余（如站点、物流渠道、地址2、备注等）一期不主动同步，除非出现真实业务需求再补齐。

### 6.3 ACK（领星 → DSCO：订单已审核/已发货回传）

DSCO ACK API：`POST /order/acknowledge`（`dsco.Order.Acknowledge`）。

ACK 条件（已确认）：

- 领星订单状态 `status` 为 `5/6`（`待发货/已发货`）即可 ACK
  - 对应枚举：`lingxing.MultiPlatformOrderStatusPendingShipment (5)` / `Shipped (6)`

领星查询来源：

- `lingxing.Order.GetOrderDetailV2`（按 `platform_order_no = po_number`）

DSCO ACK 最小必要字段：

- `OrderAcknowledgeRequest`
  - `type = PO_NUMBER`
  - `id = poNumber`

### 6.4 物流回传（领星 → DSCO：shipment）

DSCO shipment API：`POST /order/shipment/batch/small`（`dsco.Shipment.CreateSmallBatch`）。

领星数据来源与优先级（写死）：

1) 使用 `lingxing.Warehouse.WmsOrderList` 获取运单号、发货时间与实发数量：
   - 入参：
     - `platform_order_no_arr = [poNumber]`
     - `sid_arr = [SID]`：
       - SID 获取方式（写死）：从 DSCO 原始订单取 `dscoRetailerId`，通过 `runtime_config.mapping.shop` 映射得到领星 SID（字符串，需可解析为 int）
   - 取值：
     - `tracking_no`（运单号）
     - `delivered_at`（字符串时间，用于回传 DSCO 的 shipDate）
     - 若 `delivered_at` 为空：使用 `stock_delivered_at` 兜底
     - `product_info[]`（`sku` + `count`，用于实发数量）
2) 若 WmsOrderList 无数据，认为“暂未满足回传条件”，等待下次任务重试（不再用订单详情兜底拼 shipDate）。

发货时间口径（已确认，写死）：

- DSCO `shipDate` 统一取自 `WmsOrder.DeliveredAt`，并转换为 DSCO 要求的 ISO 8601/RFC3339（如 `YYYY-MM-DDTHH:MM:SSZ`）。

字段映射（最小必要字段）：

- 领星 → DSCO：
  - `tracking_no` → `trackingNumber`（必填）
  - `shipMethod`：使用 DSCO 原始订单中的 `shipMethod/requestedShipMethod`；若为空则使用 `shippingServiceLevelCode` 兜底
  - `shipDate`：使用 `WmsOrder.DeliveredAt` 转换为 RFC3339
- 发货行项目：
  - 来源：优先用 WmsOrderList `product_info[]`（SKU+count）
  - SKU 映射：领星 SKU 通过 `mapping.sku` 的**反向映射**得到 DSCO `partnerSku`（缺省同名直传）
  - DSCO 行项目标识：优先写入 `partnerSku`；如能从 DSCO 原始订单中匹配到 `dscoItemId`，可额外带上 `dscoItemId` 增强唯一性

### 6.5 发票回传（领星 → DSCO：invoice）

DSCO invoice API：`POST /invoice/batch/small`（`dsco.Invoice.CreateSmallBatch`）。

发票生成原则（已确认）：

- 发票所需“关联字段”主要来自 DSCO 原始订单（`payload`）
- **实发数量**与**订单金额**以领星侧实际出库/订单查询结果为准

数据来源（写死）：

- 领星出库与实发数量：`lingxing.Warehouse.WmsOrderList` 的 `product_info[]`
- 领星运单号/发货时间：同 6.4（与 shipment 共用）

DSCO Invoice 最小必要字段（按 SDK 结构）：

- `invoiceId`：一期策略写死为 `poNumber`；若出现“一单多出库单”需区分，则使用 `poNumber + \"-\" + wo_number`（来自 WmsOrderList）
- 订单关联字段：`poNumber`（或 `dscoOrderId` 二选一；本项目统一用 `poNumber`）
- `trackingNumber`：同 shipment
- `invoiceDate`：同 shipDate（RFC3339）
- `currencyCode`：优先从 DSCO 原始订单中取（若缺失可从领星订单详情 `amount_currency` 兜底）
- `lineItems[]`：
  - 数量：使用领星实发数量（WmsOrderList `product_info[].count`）
  - 标识字段：优先写 `partnerSku`（由 `mapping.sku` 的**反向映射**得到），并尽量补齐 `dscoItemId`
  - `unitPrice`：同 6.2 的单价规则（优先 DSCO 原始订单提供的价格字段）
- `totalAmount`：
  - 优先：领星订单详情的“订单总金额”字段（如可稳定解析为数值）
  - 兜底：按 `sum(lineItem.quantity * unitPrice)` 计算

> 注意：如 DSCO 对 totalAmount 与明细合计存在严格校验，落地实现需确保两者一致（必要时以明细合计为准）。

### 6.6 库存同步（领星 → DSCO：inventory）

目标：把领星各仓库的“可用量”同步到 DSCO inventory。

领星库存来源：

- `lingxing.Inventory.InventoryDetails`
  - 使用字段：`sku`、`product_valid_num`（可用量）、`wid`

DSCO 更新方式：

- `dsco.Inventory.UpdateSmallBatch`（异步）
  - 每个 item：`ItemInventory{ PartnerSKU, Warehouses: [{code, quantity}] }`

字段映射（最小必要字段）：

- 仓库映射：`wid`（领星） → `warehouseCode`（DSCO），使用 `mapping.warehouse` 的**反向映射**
- SKU 映射：领星 `sku` → DSCO `partnerSku`，使用 `mapping.sku` 的**反向映射**（缺省同名直传）
- 数量：`product_valid_num` → DSCO `warehouses[].quantity`

落库（用于 Admin 查询/导出）：

- `dsco_warehouse_sync`：记录每次同步的时间窗口、仓库、SKU、数量等（字段以第三章为准）

---

## 7. 任务的批量、并发与失败处理（统一口径）

批量大小：

- 所有任务统一使用 `runtime_config.config.jobs.<job>.size` 作为单次处理上限。
- DSCO/领星接口批量能力差异由实现自行拆分，但“对外配置口径”固定为 `size`。

并发：

- 不允许同一任务并发（由 runner + PostgreSQL advisory lock 保证）。

失败处理：

- 单批中部分失败：记录日志并跳过，等待下次 cron 自动重试（符合一期“简单优先”的要求）。
- 不落库失败原因；需要排查时查看日志。
