## 一、原则分类

目标：按 0→1 递进和日常演进的流程对齐，保持 MECE；每条原则给出边界（适用范围/停用条件），并标注对应价值观（新版 10 条：用户 / 业务价值优先、少即是多、可读性与一致性、清晰边界与故障隔离、可演进与可回滚、数据比代码更重要、防御与安全默认、可靠性与可观测性、自动化验证与交付、性能与成本意识）。

1. 设计与边界（从 0 起步）：切模块/服务、定职责、控耦合、抽象取舍、依赖方向。
2. 契约与类型（接口对齐）：API/Proto/DB/事件的类型与语义、兼容性、错误语义、时间/ID/单位选型。
3. 编码与实现（把契约落到代码）：可读性、函数/模块大小、错误处理、副作用隔离、可测试性、日志/指标。
4. 数据（落库与演进）：命名、生命周期、索引/扩展性、迁移/回滚、数据质量与安全。
5. 运行与可靠性（上线与运行）：超时/重试/幂等、隔离、SLO/SLI、可观测性、演练；内含安全/隐私的运行侧约束。
6. 自动化与交付（持续）：测试金字塔、预提交/CI/CD 门禁、变更说明，减少人为波动。
7. 协作与治理（长期）：ADR、DoD、评审清单、复盘、AI 使用边界；性能/成本治理放在设计/运行的对应条内指向。

# 二、软件设计原则（按分类列出：原则 | 一句话 | 边界/适用范围 | 对应价值观）

## 1. 设计与边界

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 单一职责原则 | 一个模块/服务只对一种变化原因负责 | 拆模块/服务时适用；功能极简的小工具可放宽，但需记录混合原因 | 少即是多；可演进与可回滚；清晰边界与故障隔离 |
| 职责显式化原则 | 职责要通过命名与结构一眼看出来 | 命名/目录/包结构设计时；当显式命名会泄漏隐私或安全信息时需平衡 | 可读性与一致性；清晰边界与故障隔离 |
| 边界优先原则 | 先画边界与接口，再写实现细节 | 新功能/重构立项时；一次性脚本可简化但需标注一次性性质 | 少即是多；清晰边界与故障隔离 |
| 服务自治原则 | 服务能独立演进与部署，依赖通过契约 | 多服务/子系统拆分时；紧耦合集群内库共享需说明过渡期与退出条件 | 清晰边界与故障隔离；可演进与可回滚 |
| 通信即边界原则 | 跨边界按不可靠设计，显式容错 | 跨进程/跨网络/跨团队调用必用；进程内调用可简化但不共享隐含状态 | 防御与安全默认；可靠性与可观测性 |
| 禁止结构共享原则 | 跨服务不共享内部结构（model/pb/internal），只暴露契约 | 跨服务/团队协作必守；共享库须有稳定 API 与版本化 | 清晰边界与故障隔离；可演进与可回滚 |
| 最小依赖原则 | 依赖越少，变化越可控 | 引入第三方/内部库时；可用更小粒度接口替代大依赖包 | 少即是多；可演进与可回滚 |
| 依赖方向原则 | 高层策略不依赖低层细节 | 分层/DDD/六边形架构时；实用型工具层可被上层依赖但保持纯净 | 可读性与一致性；清晰边界与故障隔离 |
| 禁止隐式依赖原则 | 依赖必须显式声明，不靠全局/默认 | 配置/依赖注入/环境变量使用时；框架隐式行为需在文档中显式化 | 防御与安全默认；可读性与一致性 |
| 必要抽象原则 | 有明确变化点或多实现再抽象 | 当下只有一个实现且无明确变化信号时不抽象；抽象需附稳定性要求 | 少即是多；可演进与可回滚 |
| 拒绝过早抽象原则 | 别为“可能的未来”付高成本 | 只有观察到真实需求/变化频率再抽象；一次性脚本不抽象 | 少即是多；可演进与可回滚 |
| 抽象稳定性原则 | 抽象比实现更难改，必须更稳定 | 发布抽象前要审视调用面；若不确定，先以适配层隔离 | 可演进与可回滚；可读性与一致性 |

**红线原则：禁止结构共享原则** — 跨服务只暴露契约，不共享内部结构。破坏边界会让演进与回滚付出全局成本，违背“清晰边界与故障隔离”“可演进与可回滚”。

## 2. 契约与类型

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 契约先行原则 | 先定 API/Proto/Schema，再做实现 | 跨团队/跨服务合作必守；内部快速实验可先实现但立即补契约 | 清晰边界与故障隔离; 用户 / 业务价值优先 |
| 一致类型原则 | API/Proto/DB/事件类型保持一致，不做隐式转换 | 跨层数据流设计时；若有转换必须显式、单点、可观测 | 可读性与一致性；数据比代码更重要 |
| 时间与 ID 明确原则 | 时间/时区/精度/溢出、ID 长度/有序性/雪花/UUID 选型前置 | 跨系统事件/DB 设计时；默认写清单位与范围 | 防御与安全默认；性能与成本意识 |
| 错误语义一致原则 | 错误码/错误类型/重试语义一致且文档化 | API/服务接口设计时；禁止把业务错误包装成 200 | 可读性与一致性；防御与安全默认 |
| 向后兼容优先原则 | 新增优于修改，修改优于删除；破坏兼容要版本化 | 对外/跨团队接口必守；内部接口破坏性变更需开关/灰度 | 可演进与可回滚；可靠性与可观测性 |
| 契约版本化原则 | Proto/API/Schema 有版本策略与生命周期 | 多客户端/多语言场景必守；废弃路径与时间线要公告 | 可演进与可回滚；自动化验证与交付 |

**红线原则：契约先行 + 向后兼容优先（组合）** — 先定契约、默认兼容。接口/Schema 的破坏性变更是下游事故高发源，直接触碰“数据比代码更重要”“可演进与可回滚”。

## 3. 编码与实现

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 可读性优先实现原则 | 代码优先易读易维护，避免聪明但晦涩的写法 | 所有长期维护代码必守；一次性脚本可放宽但需标注 | 可读性与一致性; 少即是多 |
| 小函数小模块原则 | 函数/模块保持单一层级与短小，便于理解与替换 | 核心业务必守；性能热点可合并但需注释说明意图 | 少即是多; 可演进与可回滚 |
| 副作用隔离原则 | 副作用集中在边缘，核心逻辑尽量纯函数化 | 涉 IO/网络/全局状态必守；必须共享状态时要单点封装 | 清晰边界与故障隔离; 防御与安全默认 |
| 错误显式处理原则 | 错误要显式返回与分类，带上下文；区分可重试/不可重试 | 所有对外/跨边界调用必守；性能极端路径可降日志但保留分类 | 防御与安全默认; 可靠性与可观测性 |
| 可测试性设计原则 | 通过依赖注入/接口抽象让代码易于单测/契约测 | 核心逻辑必守；一次性工具可放宽但需注明不可测范围 | 自动化验证与交付; 可演进与可回滚 |
| 日志与指标适度原则 | 关键路径有结构化日志/指标，噪声可控，避免敏感信息泄露 | 线上代码必守；高 QPS 路径需采样/限频；敏感数据脱敏 | 可靠性与可观测性; 防御与安全默认 |

**红线原则：可读性优先实现原则** — 不可读的代码让其他原则无法落地，积累隐性风险，违背“可读性与一致性”“少即是多”。

## 4. 数据

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 数据契约与质量原则 | 数据校验、Schema 约束、质量监控前置 | 入库/出库/消息发布前；异常要可观测、可告警 | 数据比代码更重要; 可靠性与可观测性 |
| 命名与生命周期明确原则 | 表/字段命名含语义，生命周期字段（created/updated/deleted）标准化 | 建模/迁移时必守；临时表需标注过期策略 | 可读性与一致性; 数据比代码更重要 |
| 索引与扩展性原则 | 为查询模式设计索引，预留扩展字段策略 | 设计表时必审查；避免宽表无边界扩展 | 性能与成本意识; 少即是多 |
| 迁移可回滚原则 | 每次数据迁移都需回滚脚本或快照方案 | 非幂等 DDL/DML 必守；演练回滚再执行 | 可演进与可回滚; 数据比代码更重要 |
| 数据安全与隐私原则 | 最小权限、脱敏、加密、审计可追踪 | 涉敏数据必守；访问需审计；备份需加密 | 防御与安全默认; 数据比代码更重要 |
| 备份与恢复演练原则 | 有备份，更要定期验证恢复 | 关键库/关键表必守；记录演练频次与结果 | 可靠性与可观测性; 可演进与可回滚 |

**红线原则：数据契约与质量原则** — 坏数据一旦入库或下发，代价最高且难补救，直接触碰“数据比代码更重要”“可靠性与可观测性”。

## 5. 运行与可靠性（含安全）

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 超时与重试有界原则 | 所有外部调用设超时，重试有上限且幂等 | 跨服务/外部调用必守；重试需避开非幂等操作 | 防御与安全默认; 可靠性与可观测性 |
| 幂等优先原则 | 可重复执行不产生副作用 | 写操作/补偿/重试场景必守；无法幂等需设计防重复 | 防御与安全默认; 数据比代码更重要 |
| 隔离与熔断原则 | 故障限制在最小单元，必要时降级/熔断 | 跨依赖调用必守；降级路径需可观测 | 清晰边界与故障隔离; 可靠性与可观测性 |
| 优雅退出原则 | 进程退出要释放资源、完成在途或显式丢弃 | 服务/作业在部署、扩缩容、宕机场景必守 | 可靠性与可观测性 |
| 可观测性覆盖原则 | 关键路径有指标/日志/追踪，关联 SLO/错误预算 | 上线前检查；无观测的功能不上线 | 可靠性与可观测性; 用户 / 业务价值优先 |
| 安全默认开启原则 | 默认最小权限、密钥/凭证安全管理、审计开启 | 所有运行环境；禁用硬编码密钥/公共桶暴露 | 防御与安全默认 |
| 演练与回滚就绪原则 | 故障注入/回滚演练常态化 | 核心路径每季度演练；未演练的变更不上核心通道 | 可演进与可回滚; 可靠性与可观测性 |

**红线原则：超时与重试有界原则** — 无界调用与盲重试最易引发级联故障，违背“防御与安全默认”“可靠性与可观测性”“清晰边界与故障隔离”。

## 6. 自动化与交付

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| 测试金字塔原则 | 单测/契约/集成/端到端分层，覆盖率与质量门禁 | 上线前；核心域强调契约/集成，外围可放宽但需说明 | 自动化验证与交付; 可演进与可回滚 |
| 预提交与 CI 门禁原则 | lint/格式/安全扫描/测试自动跑，不绿不上线 | 所有仓库；一次性脚本可跳过但需标注 | 自动化验证与交付; 防御与安全默认 |
| 变更说明与发布清单原则 | 每次上线有变更清单、风险评估、回滚方案 | 涉及用户/数据/接口变更必守；小改动可合并说明 | 可演进与可回滚; 用户 / 业务价值优先 |
| 灰度与特性开关原则 | 重要功能灰度发布，开关控制回退 | 用户可见/数据写入路径必守；开关有默认安全态 | 可演进与可回滚; 可靠性与可观测性 |

**红线原则：预提交与 CI 门禁原则** — 没有自动化门禁，质量全靠运气，违背“自动化验证与交付”“防御与安全默认”，也提高回滚概率和成本。

## 7. 协作与治理

| 原则 | 一句话 | 边界 / 适用范围 | 对应价值观 |
| --- | --- | --- | --- |
| ADR 记录原则 | 关键架构/选型决策要有 ADR，含回滚/验证方案 | 跨团队/重大变更必守；小改动可用轻量记录 | 可演进与可回滚; 可读性与一致性 |
| DoD 与评审清单原则 | 完成定义包含测试/文档/监控/安全/回滚检查 | 所有需求/特性；DoD 定期回顾更新 | 自动化验证与交付; 可靠性与可观测性 |
| 复盘与知识沉淀原则 | 故障/大变更后复盘，输出行动项并跟踪关闭 | 重大事故/回滚/性能事件必复盘 | 可演进与可回滚; 数据比代码更重要 |
| AI 使用边界原则 | 标注 AI 生成内容、校对、禁止泄密 | 涉及代码/文档的 AI 产出必校验；敏感数据禁入 | 防御与安全默认; 可读性与一致性 |

**红线原则：ADR 记录原则** — 无决策记录和回滚/验证方案，团队无法追溯/纠错，违背“可演进与可回滚”“可读性与一致性”，长期将重复踩坑。
