# Go 服务开发规范

适用范围：Go 微服务/作业/后台工具。目标：让日常开发遵循《软件开发价值观》和《软件开发原则》，特别是各分类的红线。

## 总体红线（全局适用）
- 不跨服务共享内部结构：跨边界只暴露契约（API/proto/DTO），不得直接复用对方 internal/model/pb。
- 先契约、后实现，默认向后兼容：破坏性变更必须版本化/灰度/有回滚。
- 可读性优先：代码与配置要易读可测；复杂技巧优先换成清晰实现。
- 数据正确优先于代码：入库/出库/发布消息前做校验；坏数据不上线。
- 超时与重试有界：所有外部调用设超时、有限重试且幂等；禁止盲重试。
- 自动化门禁：gofmt/lint/测试不通过不上线。
- 有决策就有 ADR：关键架构/选型/破坏性变更要记录决策与回滚方案。

## 开发流程（框架）
1) 立项&类型选择 → 选服务类型、目录模板、基础依赖。
2) 数据建模草稿 → 先以领域/用例画实体关系、主索引、关键字段（不落地 SQL）。
3) 契约草稿 → 基于数据草稿推导 API/gRPC/事件契约、错误语义、兼容策略。
4) 契约+数据双向评审 → 对齐字段/类型/单位/精度/约束/默认值/兼容策略；确定选库（SQL/NoSQL）、表/索引/迁移计划、类型映射。
5) 框架/目录落地 → 按服务类型套目录模板，生成样板代码。
6) 编码与测试 → 按编码规范、测试金字塔，CI 绿灯。
7) 观测与可靠性 → 指标/日志/追踪、超时/重试/熔断/幂等、健康检查。
8) 发布与运维 → 变更清单、灰度/开关、回滚预案、演练。

## 1. 项目结构与边界
- 目录约定：`cmd/<service>`（入口），`internal/<domain>`（内部逻辑），`pkg/<lib>`（可复用但保持稳定 API），`api/`（proto/DTO），`configs/`（配置模板），`scripts/`（工具），`deploy/`（CI/CD/Helm）。
- internal 不得跨服务依赖；公共库须放 pkg 并版本化。
- 模块/包单一职责；包内只暴露必须的接口/类型，其他放私有。
- 依赖方向：接口/用例层不依赖具体实现；适配器依赖接口。
- 抽象时机：出现 2+ 实现或明确变化点再抽象；否则保持具体实现。

## 2. 契约与类型
- 契约先行：接口/proto/schema 先评审再实现；改代码前先改契约/文档。
- 向后兼容：新增字段优先；删除/修改需版本化、灰度、观测窗口。
- 类型一致：API/proto/DB/消息的字段类型保持一致，不做隐式转换。
- 时间/ID 规范：时间统一用 `time.Time`（UTC）或毫秒/纳秒 int64（写明单位）；ID 长度/有序性选型前置（UUIDv4/雪花），写入/索引要评审。
- 错误语义：错误码/错误类型/重试语义一致且文档化；业务错误不返回 200。
- 契约版本化：proto/API/Schema 有版本策略，废弃路径和时间线可查询。

## 3. 编码与实现
- 可读性：强制 gofmt；命名清晰；小函数/小文件；避免魔数（常量化）。
- 命名：包/文件小写；变量/函数用有意义的英文名，避免缩写；接口用行为命名（`Doer`），实现用具体名。
- 逻辑复杂度：尽量使用 guard clause，避免 if/else 深嵌套（建议不超 3 层）；可用表驱动/策略替代分支爆炸。
- 接口与依赖注入：接口小而专注；依赖显式传入（构造函数/函数参数），少用全局。
- 上下文：跨边界函数必须传 `context.Context`；不得将 ctx 存全局。
- 副作用隔离：IO/网络放在适配层；核心逻辑尽量纯函数，便于测试与重用。
- 错误处理：显式返回错误，使用 `errors.Wrap` 类模式保留上下文；区分可重试/不可重试；严禁吞错。
- 禁止忽略错误：不得使用 `_ = err` 吞错；不得直接 `if err != nil { return }` 不带上下文。
- 日志与指标：结构化日志，统一 logger；避免打印敏感信息；高 QPS 路径需采样/限频。关键路径暴露指标（QPS/latency/error），埋点携带 trace/span。
- 配置：使用配置文件/环境变量，默认安全值；配置热更新需验证与回滚策略。
- 并发：创建 goroutine 必可控退出（ctx/stop chan）；避免泄漏；channel 容量合理。
- 复用：优先复用 pkg 或第三方库，但评估稳定性与最小依赖。

## 4. 数据访问
- 数据契约与校验：入库/出库/消息发布前做校验，禁止无校验写入。
- 命名与生命周期：表/字段命名语义化；created_at/updated_at/deleted_at/is_delete 标准化。
- 访问模式：统一 ORM/SQL 工具；必须使用预编译/参数化，禁止拼接 SQL；扫描 null 字段用合适类型（sql.Null* 或指针）。
- 事务：显式事务边界；必要时加超时；禁止长事务持锁。
- 索引与查询：为主查询场景设计索引；避免无谓全表扫描；变更前评审。
- 迁移：使用迁移工具（如 goose/tern/atlas），每次迁移必须有回滚脚本，先演练再上线。
- 数据安全：最小权限；敏感字段加密/脱敏；备份需加密，定期恢复演练。

## 5. 运行与可靠性（含安全）
- 超时与重试：HTTP/gRPC/DB/Cache/Kafka 等外部调用必须设置超时；重试有限次且幂等，使用指数退避；避免重试风暴。
- 幂等：写操作设计幂等键或去重机制；补偿/重放必须幂等。
- 隔离/熔断/降级：跨依赖调用配置隔离（连接池/线程池/队列），提供降级路径；熔断后快速失败。
- 健康检查：区分 liveness/readiness；依赖不可用时 readiness 失败。
- 优雅退出：监听信号，阻止新请求，等待在途完成或超时丢弃，清理资源。
- 可观测性：关键路径有指标/日志/追踪；定义 SLO/错误预算；无观测不准上线。
- 安全默认开启：TLS、证书校验、最小权限、密钥不落盘；避免在日志/指标中泄露敏感数据。
- 演练：故障注入/回滚/灾备演练常态化；未演练的变更不上核心路径。

## 6. 自动化与交付
- 预提交：必须 gofmt（或 gofumpt）、goimports、lint（golangci-lint），单元/契约测试；不绿不上线。
- CI/CD：流水线至少跑 fmt/lint/test(-race)/构建/镜像扫描/部署前检查；构建产物可复现（版本号、提交哈希）。
- 测试金字塔：单元测试覆盖核心逻辑（含错误路径）；契约测试覆盖接口契约；集成测试覆盖关键链路（含 DB/缓存/消息）；端到端/回归覆盖用户路径；关键库和并发敏感代码跑 `go test -race`。
- 变更说明：每次上线需变更清单、风险评估、回滚方案；大改动先灰度/特性开关。
- 环境一致性：开发/预发/生产尽量同构；配置通过环境覆盖，禁止硬编码。

## 7. 协作与治理
- ADR：关键架构/选型/破坏性变更产出 ADR，包含背景、选项、决策、验证与回滚方案。
- DoD & 评审：需求完成需通过 DoD（测试、文档、监控、安全、回滚检查）；评审清单覆盖契约、边界、可靠性、安全、性能。
- 复盘：故障/回滚/性能事件后复盘，行动项跟踪关闭。
- AI 使用边界：标注 AI 生成内容；必须人工校对；敏感数据不得输入/输出。

## 8. 参考价值观映射
- 边界/耦合/抽象：少即是多；可读性与一致性；清晰边界与故障隔离；可演进与可回滚。
- 契约/类型/数据：数据比代码更重要；可演进与可回滚；防御与安全默认。
- 运行/可靠性/安全：防御与安全默认；可靠性与可观测性。
- 自动化/交付/治理：自动化验证与交付；可演进与可回滚；用户/业务价值优先；性能与成本意识。
